#autoline 1,5
#autostart 1
#program marbles

;-------------------------------------------------------------------------------
; VARIABLES
;
; %p() - player state
; i$   - input key
; s$   - temp printed string
;
;-------------------------------------------------------------------------------

RUN AT 3
TESTING=1
BORDER 0: PAPER 0: CLS
ON ERROR GO TO 9200

#define BANKPAL=15
#define BANK_ZEROS=15
#define BANKSPR=16
#define BANK_TILE_SPR=17
#define BANK_TILES=18
#define BANKPLOT=19
#define BANKLIB=20
#define BANKGFX_A=22
#define BANKGFX_B=23
#define BANKGFX_C=28
#define BANK_FX=24
#define BANK_REMOTE_SCORES=25
#define BANK_LOCAL_SETTINGS=26
#define BANK_UNDO=27
#define BANK_FONTS=29
#define BANK_CUSTOM_THEME=21

# set debug bank to non zero to load predefined sequence
#define BANKDEBUG=0

# plot data structure
# seed[2]
# moves_length[2]
# moves[...]
# name[3]

# high score structure
# name[3]
# seed[2]
# score[2]
# [...]

#define DRV_FX=49

#define FONT_COMPUTING_60=0
#define FONT_COAL=1

; bank graphic offsets
#define OFFSET_CONTROLS=0
#define OFFSET_NEW_GAME_BOX=5632
#define OFFSET_NEXT_LEVEL=11392
#define OFFSET_GAME_OVER=0
#define OFFSET_TITLE=2560
#define OFFSET_CONTROLS_ALT=0
#define OFFSET_ALERT=5632
#define OFFSET_ALERT_T=5632
#define OFFSET_ALERT_M=6528
#define OFFSET_ALERT_B=7424
#define OFFSET_ZEROS=512

; entry points in the marbles.bin library for methods and method constants
#define M_CANMOVE=432
#define M_RANDOMSEED=434
#define M_FN_POPULATEGRID=454
#define M_TAGINDEX=499
#define M_FN_TAG=498
#define M_FN_MIXMAX=924

#define POINTER=127
#define POINTERSPR=63
#define COUNTER=126
#define FAKESPR=4

; user state
#define DEVICE=1
#define SCORE=2
#define BUSY=3
#define BLOCKSLEFT=4
#define BEST=5
#define THEME=6
#define PLOTPTR=7
#define SEED=8
#define LEVEL=9
#define LOAD_PATTERN=10
#define GOT_HIGH_SCORE=11
#define UNDO_PTR=12
#define LAST_CLEARED=13
#define CUSTOM_THEME=14

#define KEYBAORD=0
#define JOYSTICK=1
#define MOUSE=2
#define NOT_SELECTED=4

#define EMPTY=54

%p(#DEVICE)=#KEYBAORD
%p(#SCORE)=0
%p(#CUSTOM_THEME)=0
%p(#THEME)=%5*5: ; or 2*5
RANDOMIZE
%p(#SEED)=%1+ RND $ffff
%p(#BEST)=0
%p(#UNDO_PTR)=0

h$="data.remysharp.com"

PROC reset()
PROC loadAssets()

; testing screens
; PROC installInput()
; PROC testMenus()
; PROC splash()
; PROC debugStop()
; PROC testGameOver()
; PROC testMarlbesClear()
; PROC testSelectAnimation()

PROC gameLoop()

PAUSE 0

DEFPROC testMenus()
  PROC settingsMenu()
  PROC debugStop()
ENDPROC

DEFPROC testLoadBanks()
  ; used in testing
  LOAD "assets/marbles.pal" BANK #BANKPAL,0,512
  LOAD "assets/font-computing-60s.bin" BANK #BANK_FONTS,0,768
  LOAD "assets/font-coal.bin" BANK #BANK_FONTS,768,768
  LOAD "assets/controls.nxi" BANK #BANKGFX_A,#OFFSET_CONTROLS,5632: ; 88w
  LOAD "assets/new-game.nxi" BANK #BANKGFX_A,#OFFSET_NEW_GAME_BOX,5760: ; 120w
  LOAD "assets/next-level-small.nxi" BANK #BANKGFX_A,#OFFSET_NEXT_LEVEL,3840: ; 80w
  LOAD "assets/game-over.nxi" BANK #BANKGFX_B,#OFFSET_GAME_OVER,2560: ; 160w
  LOAD "assets/title.nxi" BANK #BANKGFX_B,#OFFSET_TITLE,12672: ; 176w
  LOAD "assets/controls-alt.nxi" BANK #BANKGFX_C,#OFFSET_CONTROLS_ALT,5632: ; 88w
  LOAD "assets/alert.nxi" BANK #BANKGFX_C,#OFFSET_ALERT,2688: ; 112w (3 rows of 8px)

  ; marbles library
  LOAD "assets/marbles.bin" BANK #BANKLIB
  LOAD "assets/marbles.spr" BANK #BANKSPR

  ; audio
  LOAD "assets/marbles.afb" BANK #BANK_FX

ENDPROC

DEFPROC testNumbers()
  PROC startGame(%p(#SEED))
  %p(#SCORE)=62345
  PROC nextLevel()
  PROC debugStop()
ENDPROC

DEFPROC testMarlbesClear()
  PROC startGame(%p(#SEED))
  SPRITE PRINT 0
  FOR %j=0 TO 99
    PROC toXY(%j) TO %x,%y
    TILE 1,1 AT 0,1 TO %x,%(y+1)
  NEXT %j
  TILE 10,10 AT 0,4 TO 0,1
  PROC debugStop()
ENDPROC

DEFPROC testGameOver()
  PROC startGame(%p(#SEED))
  PROC gameOver()
  IF i$="n" THEN PROC newGame()
  PROC onAnyKey()
  PROC debugStop()
ENDPROC

DEFPROC testSelectAnimation()
  %p(#SEED)=%$9999
  PROC startGame(%p(#SEED))
  SPRITE #POINTER,55,68,,,
  PROC select()
  PROC debugStop()
ENDPROC

DEFPROC gameLoop()
  REPEAT
    SPRITE PRINT 0
    PROC splash()
    PROC startGame(%p(#SEED))

    ; in-game UI control
    REPEAT
      PROC readInput()
      IF i$="r" THEN PROC replayGame()
      IF i$="n" THEN PROC newGame()
      IF i$="u" THEN PROC undo()
    REPEAT UNTIL i$="e"

    ; disable the block sprites
    %n=100
    SPRITE PRINT 0
    REPEAT
      SPRITE %n,,,,0
      %n=%n-1
    REPEAT UNTIL %n=0

    ; exit the game - re-render our outer border
    PROC setGameBorder()
  REPEAT UNTIL 0
ENDPROC

DEFPROC splash()
  PROC printLayer()

  LAYER 2,1
  LOCAL %i

  ; just a little effect that makes the title text render from top and bottom
  ; at the same time (14 > i > 4)
  %i=13
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  %i=5
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  PAUSE 2
  %i=12
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  %i=6
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  PAUSE 2
  %i=11
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  %i=7
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  PAUSE 2
  %i=10
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  %i=7
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  PAUSE 2
  %i=9
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  %i=8
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1

  PROC font(1,4)
  PRINT AT 15,15;"Plan ahead...or lose embarrassingly."
  INK 50
  PRINT AT 17,19;"A puzzle game by Remy Sharp"

  PAUSE 220

  BANK #BANK_ZEROS LAYER #OFFSET_ZEROS TO 5,14,22,7

  PROC mainMenu()
ENDPROC

DEFPROC mainMenu()
  PROC font(0,8)
  PROC printLayer()
  LOCAL %i
  LET start=0
  PROC printMainMenuOptions()
  PROC untilKeyUp()
  %i=0
  REPEAT
    k$= INKEY$
    IF k$="1" THEN start=1
    IF k$="2" THEN PROC showHighScores()
    IF k$="4" THEN PROC settingsMenu()
;     IF (k$ > "3") THEN : ELSE : PROC showHighScores(): PROC setSeed(%p(#SEED)):start=1: ELSE PROC printMainMenuOptions()
  REPEAT UNTIL start=1

ENDPROC


DEFPROC printMainMenuOptions()
  LAYER 2,1
  BANK #BANKGFX_B LAYER %#OFFSET_TITLE TO 5,5,22,9

  DIM j$(4,18)
  j$(1)="1. Free play"
  j$(2)="2. Challenge"
  j$(3)="3. Highscores"
  j$(4)="4. Settings"

  LAYER 1,1
  INK 2
  PRINT POINT 72,%(1*12)+105;"1. Free play"
  PRINT POINT 72,%(2*12)+105;"2. Challenge"
  PRINT POINT 72,%(3*12)+105;"3. Highscores"
  PRINT POINT 72,%(4*12)+105;"4. Settings"

ENDPROC

DEFPROC clearL2Menu()
  LAYER 2,1
  BANK #BANK_ZEROS LAYER #OFFSET_ZEROS TO 5,4,22,9
  BANK #BANK_ZEROS LAYER #OFFSET_ZEROS TO 5,12,22,9
ENDPROC

DEFPROC setGameBorder()
  PROC printLayer()
  CLS
  LAYER 2,1
  PAPER 254: INK 255
  IF TESTING THEN LOAD "assets/welcome.nxi" LAYER
  IF TESTING=0 THEN :.extract MARBLES.BAS +86308 49152 -mb 9 : ; welcome

  LAYER 1,1
ENDPROC

DEFPROC showHighScores()
  PROC clearL2Menu()
  b$= STR$ #BANK_REMOTE_SCORES
  ON ERROR ON ENDPROC : ; fixme - do some kind of error handling
  .http get -h h$ -u /6 -b b$ -7
  PROC renderHighScores()
ENDPROC

DEFPROC renderHighScores()

  LOCAL %i: ; memory peek position
  LOCAL %j: ; screen print offset
  LOCAL %k: ; high score position (1..10)
  LOCAL %l: ; whether to print inverted
  PROC printLayer()

  CLS

  PAPER 1
  INK 2
  PRINT AT 5,11;"HIGH SCORES"

  %i=0
  %k=1
  %j=1
  REPEAT
    WHILE % BANK #BANK_REMOTE_SCORES PEEK i <> 0

    n$= BANK #BANK_REMOTE_SCORES PEEK$ (%i,3)
    %j=% BANK #BANK_REMOTE_SCORES DPEEK (i+3): ; seed
    PROC toHex(%j) TO s$
    %s=% BANK #BANK_REMOTE_SCORES DPEEK (i+5): ; score

    %i=%i+7

    PRINT AT %6+(i/7),%5-(k/10);

    PRINT %k;".";
    IF %l=0 THEN INK 2
    PRINT n$;
    IF %l=0 THEN INK 3
    PRINT "   #";s$;"    ";
    PROC pad4(%s) TO s$
    IF %l=0 THEN INK 2
    PRINT s$;%s
    %k=%k+1

  REPEAT UNTIL %i=0

  PRINT AT 19,7;"Challenge? "; FLASH 1;"Y"; FLASH 0;"es/No"
  PRINT AT 21,18;"▀"

  REPEAT
    k$= INKEY$
  REPEAT UNTIL k$="y" OR k$="n" OR ( CODE k$)=13
  REPEAT : REPEAT UNTIL INKEY$ =""

  IF k$="n" THEN PRINT AT 20,18;"   ▀": ENDPROC =0

  ; wait loop
  PRINT AT 19,4;"Use cursors keys & enter"
  PRINT AT 20,18;" "

  %i=0
  %j=%((i+7)*32)+6144
  FOR %k=%(j+4) TO %(j+26)
    %l=% BANK 5 PEEK k
    BANK 5 POKE %k,%(l^128)
  NEXT %k

  REPEAT
    k$= INKEY$
    %c= CODE k$
    IF %(c >= 9) AND (c <= 11) THEN PROC highlight(%c,%i) TO %i
  REPEAT UNTIL %c=13

  %p(#SEED)=% BANK #BANK_REMOTE_SCORES DPEEK ((i*7)+3): ; seed
ENDPROC =1

DEFPROC gameLayer()
  LAYER OVER 0
  LAYER 2,1
  PALETTE OVER 227
  CLS
ENDPROC

DEFPROC printLayer()
  LAYER OVER 0
  LAYER 1,1
  PALETTE OVER 0
ENDPROC

DEFPROC highlight(%c,%i)

  %j=%((i+7)*32)+6144
  FOR %k=%(j+4) TO %(j+26)
    %l=% BANK 5 PEEK k
    BANK 5 POKE %k,%(l^128)
  NEXT %k

  IF %c=11 THEN IF %i > 0 THEN %i=%i-1: ; up
  IF %c=8 THEN IF %i > 0 THEN %i=%i-1: ; left (aka up)
  IF %c=10 THEN IF %i < 9 THEN %i=%i+1: ; down
  IF %c=9 THEN IF %i < 9 THEN %i=%i+1: ; right (aka down)

  ; invert the row
  %j=%((i+7)*32)+6144
  FOR %k=%(j+4) TO %(j+26)
    %l=% BANK 5 PEEK k
    BANK 5 POKE %k,%(l^128)
  NEXT %k
ENDPROC =%i

DEFPROC saveHighScore()
  BANK #BANK_LOCAL_SETTINGS DPOKE 2,%p(#SCORE)
  BANK #BANK_LOCAL_SETTINGS DPOKE 4,%p(#SEED)

  ; TODO manage high score table
  SAVE "marbles.dat" BANK #BANK_LOCAL_SETTINGS,0,46
ENDPROC

DEFPROC restoreSettings()
  %p(#DEVICE)=% BANK #BANK_LOCAL_SETTINGS PEEK 0
  %p(#THEME)=% BANK #BANK_LOCAL_SETTINGS PEEK 1
  %p(#BEST)=% BANK #BANK_LOCAL_SETTINGS DPEEK 2
ENDPROC

DEFPROC underline(%y,%x)
  LOCAL %b

  ; set the bank and adjust the Y offset
  IF %y < 8 THEN %b=9:%y=%y*2048: ELSE : IF %y < 16 THEN %b=10:%y=%(y-8)*2048: ELSE :%b=11:%y=%(y-16)*2048

  %x=%x*8

  BANK %b DPOKE %y+x,%$0f0f,%$0f0f,%$0f0f,%$000f: ; 8 pixels underline
ENDPROC

DEFPROC settingsMenu()
  PROC clearL2Menu()
  LAYER 2,1
  PALETTE OVER 227

  INK 255
  PRINT AT 5,12;"Settings"

  DIM j$(3,15)
  j$(1)="Keyboard (QAOP)"
  j$(2)="Joystick"
  j$(3)="Mouse"

  DIM t$(9,15)
  t$(1)="Diamonds"
  t$(2)="Original"
  t$(3)="Numberwang"
  t$(4)="Kitchen Floor"
  t$(5)="Next Speccy"
  t$(6)="New Grey"
  t$(7)="Old Spec"
  t$(8)="No Hope"
  t$(9)="Custom"

  LOCAL %i: LOCAL i: LOCAL %j
  i=%p(#DEVICE)

  PRINT AT 9,5; INK 255;"I"; INK 50;"nput:"
  PROC underline(10,5)
  PRINT AT 9,12;j$(i+1)
  PRINT AT 12,5; INK 255;"T"; INK 50;"heme:"
  PROC underline(13,5)
  PRINT AT 19,10; INK 255;"S"; INK 50;"ave Settings"
  PROC underline(20,10)

  PROC pointerStatus(0)

  ; turn off all sprites

  SPRITE PRINT 1
  SPRITE PALETTE 0 BANK #BANKPAL,0
  PROC printTheme()

  i=%p(#THEME)/5
  PRINT AT 14,12; INK 52;t$(i+1)

  PROC font(1,4)

  PRINT AT 16,10; INK 50;"Want your own custom theme?"
  PRINT AT 17,10; INK 50;"Add THEME.SPR to the game directory"

  PROC font(0,8)

  IF %p(#CUSTOM_THEME) THEN %j=45: ELSE :%j=40

  REPEAT
    k$= INKEY$
    IF k$="i" THEN %p(#DEVICE)=%((p(#DEVICE)+1) MOD 3):i=%p(#DEVICE): PRINT AT 9,12;j$(i+1)
    IF k$="t" THEN %p(#THEME)=%(p(#THEME)+5) MOD j:i=%p(#THEME)/5: PROC printTheme(): PRINT AT 14,12; INK 52;t$(i+1)

    IF k$ <> "" THEN PROC untilKeyUp()
  REPEAT UNTIL k$="s"

  k$=""

  PALETTE OVER 0
  SPRITE PRINT 0

  PROC disableTheme()
  PROC clearL2Menu()

  ; save settings
  BANK #BANK_LOCAL_SETTINGS POKE 0,%p(#DEVICE)
  BANK #BANK_LOCAL_SETTINGS POKE 1,%p(#THEME)
  SAVE "marbles.dat" BANK #BANK_LOCAL_SETTINGS,0,46

  PROC printMainMenuOptions()

ENDPROC

DEFPROC printTheme()
  ; note: this palette switch doesn't quite solve the issue when
  IF %p(#THEME)=40 THEN SPRITE PALETTE 1: ELSE SPRITE PALETTE 0
  SPRITE 101,%128,%124,%p(#THEME),1
  SPRITE 102,%144,%124,%p(#THEME)+1,1
  SPRITE 103,%160,%124,%p(#THEME)+2,1
  SPRITE 104,%176,%124,%p(#THEME)+3,1
ENDPROC

DEFPROC disableTheme()
  SPRITE 101,,,,0
  SPRITE 102,,,,0
  SPRITE 103,,,,0
  SPRITE 104,,,,0
ENDPROC

DEFPROC readInput()
  i$= INKEY$
  IF %p(#DEVICE)=#MOUSE THEN PROC readMouse(): ELSE PROC readJoystick()
ENDPROC

DEFPROC readMouse()
  DRIVER 126,1 TO %b,%x,%y
  SPRITE #POINTER,%x/2,%y,,,
  IF %b&@111 THEN PROC select()
ENDPROC

DEFPROC readJoystick()
  ; note the REM below *must* be kept for the joystick driver to work
  DRIVER 125,4,1
  REM 12345678901234567890123456789012345678901234567890
ENDPROC

DEFPROC select()
  IF %p(#BUSY) THEN ENDPROC
  %i=%( SPRITE OVER (#POINTER,1 TO 100)): ; which block are we over when we selected

  ; colliding 0 sprite returns 128 (can't remember why though!)
  IF %i=128 THEN %i=0

  IF %i=0 THEN ENDPROC
  IF %i > 100 THEN ENDPROC : ; out of scope

  %i=%i-1
  PROC selectBlock()
ENDPROC

; %i = selected block
; Uses: %c, %i, %t
; Modifies: %p
DEFPROC selectBlock()
  IF %p(#BUSY) THEN ENDPROC

  %p(#BUSY)=1

  ; load %i into tagIndex
  BANK #BANKLIB POKE #M_TAGINDEX,%i
  ; call Tag()
  %t=% BANK #BANKLIB USR #M_FN_TAG

  ; %t contains the address of the number of blocks tagged (which is actually static)
  %c=% BANK #BANKLIB PEEK t

  IF %c < 2 THEN %p(#BUSY)=0: ENDPROC

  DRIVER #DRV_FX,2,1: ; play the "clack" sound

  %p(#SCORE)=%p(#SCORE)+(c*(1+c))
  %p(#LAST_CLEARED)=%c
  %p(#BLOCKSLEFT)=%p(#BLOCKSLEFT)-c
  BANK #BANKPLOT POKE %p(#PLOTPTR),%i: ; store the block cleared
  %p(#PLOTPTR)=%p(#PLOTPTR)+1
  BANK #BANKPLOT DPOKE 2,%p(#PLOTPTR)-4: ; add the count of moves to the data

  IF %p(#SCORE) > p(#BEST) THEN %p(#BEST)=%p(#SCORE):%p(#GOT_HIGH_SCORE)=1

  PROC captureUndo()

  ; clear the tagged blocks

  ; first commit them all as tiles
  ; then add new sprites as animations over those position
  ; fire the animation 3 times
  ; then empty them out

  %k=% BANK #BANKLIB USR #M_FN_MIXMAX
  %a=%(k >> 8)+1: ; min sprite id
  %b=%(k&$00FF)+1: ; max sprite id - required to disable later

  %k=0
  FOR %i=1 TO %c
    %j=% BANK #BANKLIB PEEK (t+i)
    %k=%j+1
    PROC toXY(%j) TO %x,%y
    %m=% SPRITE AT (k,2)
    SPRITE %k,,,51,
    TILE 1,1 AT 0,%m-p(#THEME) TO %x,%(y+1)
    SPRITE CONTINUE %k, STOP , STOP ,51 TO 54, BIN 01100000,10,0
  NEXT %i

  ; animate the frames and then disable the sprite animation when it's done
  SPRITE STOP
  REPEAT
    SPRITE MOVE
    %i=% SPRITE AT (k,2)
  REPEAT UNTIL %i=54
  SPRITE RUN

  ; now disable the sprites that were animating
  SPRITE PAUSE %a TO %b

  ; LAYER ERASE 0,0,80,80,0: ; breaks in cspect
  ; so instead we'll tile the "black" tile over the area (hidden by sprites)
  TILE 10,10 AT 0,4 TO 0,1

  INK 50
  PROC pad2(%c) TO s$
  PRINT AT 3,21;"CLEARED ";s$;%c
  PROC pad2(%p(#PLOTPTR)-4) TO s$
  PRINT AT 4,21;"MOVES   ";s$;%(p(#PLOTPTR)-4)
  PROC pad2(%p(#BLOCKSLEFT)) TO s$
  PRINT AT 5,21;"REMAIN  ";s$;%p(#BLOCKSLEFT)
  INK 255
  PROC pad4(%p(#SCORE)) TO s$
  PRINT AT 2,21;"SCORE ";s$;%p(#SCORE)

  ; now full render
  %c=100
  REPEAT
    %c=%c-1
    %i=% BANK #BANKLIB PEEK c
    IF %i < 255 THEN %i=%i+p(#THEME): ELSE %i=#EMPTY
    SPRITE %c+1,,,%i,
  REPEAT UNTIL %c=0

  %p(#BUSY)=0

  IF %( BANK #BANKLIB PEEK #M_CANMOVE)=0 THEN %p(#BUSY)=1: PAUSE 10: PROC gameOver()
  IF %p(#BLOCKSLEFT)=0 THEN PROC nextLevel()

ENDPROC

DEFPROC debugStop()
  REPEAT : REPEAT UNTIL INKEY$ <> ""
  STOP
ENDPROC

DEFPROC captureUndo()
  BANK #BANKLIB COPY 0,100 TO #BANK_UNDO,%p(#UNDO_PTR)
  BANK #BANK_UNDO DPOKE %(p(#UNDO_PTR)+100),%p(#SCORE),%p(#BLOCKSLEFT),%p(#LAST_CLEARED)
  %p(#UNDO_PTR)=%p(#UNDO_PTR)+106
ENDPROC

DEFPROC undo()
  IF %p(#UNDO_PTR) <= 106 THEN ENDPROC : ; no more undo
  IF %p(#BUSY) THEN ENDPROC

  LOCAL %o
  LOCAL %i
  LOCAL %c

  %p(#BUSY)=1

  ; this looks weird because it's 2 undo states, but it's because the tip is
  ; inclusive of the latest change, so moving back one state is 106 bytes, which
  ; is at the start of the current state, and once more takes us to the previous
  ; state, then we save the point to the end of that.
  %o=%p(#UNDO_PTR)-(106*2)

  ; reset undo position
  %p(#UNDO_PTR)=%(o+106)

  ; restore state
  BANK #BANK_UNDO COPY %o,100 TO #BANKLIB,0
  %p(#SCORE)=% BANK #BANK_UNDO DPEEK (o+100)
  %p(#BLOCKSLEFT)=% BANK #BANK_UNDO DPEEK (o+102)
  %p(#LAST_CLEARED)=% BANK #BANK_UNDO DPEEK (o+104)
  %p(#PLOTPTR)=%p(#PLOTPTR)-1
  BANK #BANKPLOT DPOKE 2,%(p(#PLOTPTR)-4)

  ; print game stats
  INK 255
  PROC pad4(%p(#SCORE)) TO s$
  PRINT AT 2,21;"SCORE ";s$;%p(#SCORE)
  INK 50

  PROC pad2(%p(#LAST_CLEARED)) TO s$
  PRINT AT 3,21;"CLEARED ";s$;%p(#LAST_CLEARED)

  PROC pad2(%p(#PLOTPTR)-4) TO s$
  PRINT AT 4,21;"MOVES   ";s$;%(p(#PLOTPTR)-4)
  PROC pad2(%p(#BLOCKSLEFT)) TO s$
  PRINT AT 5,21;"REMAIN  ";s$;%p(#BLOCKSLEFT)

  ; render
  %c=100
  REPEAT
    %c=%c-1
    %i=% BANK #BANKLIB PEEK c
    IF %i < 255 THEN %i=%i+p(#THEME): ELSE %i=#EMPTY
    SPRITE %c+1,,,%i,
  REPEAT UNTIL %c=0

  %p(#BUSY)=0
ENDPROC

; 24 characters per line
DEFPROC alert(a$,b$)
  LOCAL %i
  BANK #BANKGFX_C LAYER #OFFSET_ALERT_T TO 7,9,14,1
  BANK #BANKGFX_C LAYER #OFFSET_ALERT_M TO 7,10,14,1
  BANK #BANKGFX_C LAYER #OFFSET_ALERT_M TO 7,11,14,1

  BANK #BANKGFX_C LAYER #OFFSET_ALERT_M TO 7,12,14,1

  %i=13

  ; if there's something in b$
  IF b$ <> "" THEN %i=14: BANK #BANKGFX_C LAYER #OFFSET_ALERT_M TO 7,13,14,1

  BANK #BANKGFX_C LAYER #OFFSET_ALERT_B TO 7,%i,14,1

  ; select small font
  PROC font(1,4)
  INK 252: PAPER 253
  PRINT AT 11,16;a$
  IF b$ <> "" THEN PRINT AT 12,16;b$

  ; return font to normal
  PROC font(0,8)
ENDPROC

DEFPROC gameOver()
  LOCAL %i
  LOCAL %j
  %i=0
  %j=0
  i$=""

  ; disable the pointer
  PROC pointerStatus(0)

  BANK #BANKGFX_C LAYER #OFFSET_CONTROLS_ALT TO 21,13,11,8

  ; play a gameover sound
;   DRIVER #DRV_FX,2,0

  ; TODO save their last game to disk
  n$="REM"
  BANK #BANKPLOT POKE %p(#PLOTPTR),n$
  %p(#PLOTPTR)=%p(#PLOTPTR)+3
  %p(#BUSY)=1
;   SAVE "last.bnk" BANK #BANKPLOT,0,%p(#PLOTPTR)
  IF %p(#GOT_HIGH_SCORE) THEN PROC saveHighScore(): PROC postHighScore()

  %a(0)=%$cf: ; mint
  %a(1)=%$38: ; green
  %a(2)=%$87: ; dark purple
  %a(3)=%$3f: ; cyan

  REG 67,% BIN 10010000 : ; disable palette auto increment
  REG 64,136: ; select index 136

;   PROC alert("YOU KNOW YOU CAN UNDO","INSTEAD OF KEEP LOSING")
;   PROC alert("    OH. YOU BLEW IT.","")
;   PROC alert("MY ONE LEGGED CAT GOT","A BETTER SCORE THAN THAT")
;   PROC alert("KEEP PRACTISING.","'COS YOU LOST...AGAIN...")
  PROC alert("    NICE TRY MEATBAG    ","        TRY AGAIN")
;   PROC alert("    I DIDNT KNOW THE","    SCORE WENT THAT LOW")
  BANK #BANKGFX_B LAYER #OFFSET_GAME_OVER TO 5,22,20,2
  REPEAT
    ; this rotates the "game over" text as a layer draw - though it should be a
    ; palette rotation which would be hugely faster
    IF %j&31=0 THEN %i=%(i+1) MOD 4: REG %68,%a(i): REG %68,%$81
    %j=%j+1
    i$= INKEY$
  REPEAT UNTIL (i$="r") OR (i$="n") OR (i$="e")

  REG 67,% BIN 00010000 : ; re-enable palette auto increment

  %p(#BUSY)=0

  ; clear the section that showed game over
  BANK 11 ERASE 12288,4096,0
  ; wipe this area of the screen using a layer print (layer erase doesn't work in cspect) - note that I can't (easily) use tile here because my tiles are 16px
  ; and we need to tile over an odd (by 8px) width
  BANK #BANK_ZEROS LAYER #OFFSET_ZEROS TO 0,6,21,10

ENDPROC

DEFPROC pointerStatus(%i)
  SPRITE #POINTER,,,,%i,
ENDPROC

DEFPROC postHighScore()
  ; TODO prompt for name - limit 3
  l=%p(#PLOTPTR)
  l$= STR$ l
  b$= STR$ #BANKPLOT

  ON ERROR ENDPROC

  ; post to data.remysharp.com/6 - flash with white and base64 encode
  .http post -b b$ -l l$ -h h$ -u /6 -v 7 -7
ENDPROC

; param {int} %i
; returns {string} hex string
; uses: %j, h$, r$, p
DEFPROC toHex(%i)
  LOCAL %j
  LOCAL h$
  LOCAL r$
  LOCAL p
  %j=4: ; symbols (2 bytes = 4 symbols)
  h$="0123456789abcdef"
  r$=""
  REPEAT : WHILE %j <> 0
    %j=%j-1
    p=%(i&$f)+1
    r$=h$(p)+r$
    %i=%i >> 4
  REPEAT UNTIL 0
ENDPROC =r$

DEFPROC fromHex(s$)
  LOCAL i: ; counter (since we need to splice)
  LOCAL %j: ; int value for i
  LOCAL %l: ; string length
  LOCAL %r: ; return value
  LOCAL c$: ; current char
  LOCAL %i: ; numeric value of current char

  %l= LEN (s$)

  %r=0

  FOR i=%l TO 1 STEP -1
    c$=s$(i TO i)
    %i= CODE c$
    IF %i > $46 THEN %i=%i-$20: ; to uppercase
    IF %i > $39 THEN %i=%i-$37: ELSE %i=%i-$30: ; to number

    %j=i
    %r=%r+((i)*(1 << ((l-j)*4)))
;     PRINT c$;"-";%i;"-";%1 << ((l-j)*4)
  NEXT i
ENDPROC =%r

DEFPROC nextLevel()
  %p(#LEVEL)=%p(#LEVEL)+1
  %p(#UNDO_PTR)=0: ; reset the undo

  ; show Next Level box
  BANK #BANKGFX_A LAYER #OFFSET_NEXT_LEVEL TO 5,9,10,6

  SPRITE #COUNTER,97,116,58,1, BIN 0,1,1
  SPRITE #COUNTER-1,97,116,62,1, BIN 0,1,1: ; put a sprite under the countdown that's solid white, just in case we hide the counter before we clear the screen
  SPRITE CONTINUE #COUNTER, STOP , STOP ,58 TO 61, BIN 01100000,60,60: ; count down effect

  REPEAT
    SPRITE MOVE INT
  REPEAT UNTIL % SPRITE #COUNTER=0

  SPRITE #COUNTER-1,,,,0: ; remove the backing sprite

  ; remove only the "new level" box that we painted
  LAYER ERASE 40,72,80,48
  PROC printSeed()
  PROC loadBlocks()
ENDPROC

DEFPROC startGame(%s)
  LAYER 2,1
  INK 255: PAPER 0
  CLS
  PROC gameLayer()
  PROC font(0,8)
  SPRITE PRINT 0
  %p(#LEVEL)=1
  %p(#SCORE)=0
  %p(#BUSY)=0
  %p(#LAST_CLEARED)=0
  %p(#UNDO_PTR)=0
  %p(#GOT_HIGH_SCORE)=0
  BANK #BANKPLOT ERASE %$7f
  BANK #BANKPLOT DPOKE 0,%s: ; first 16bit word is the seed
  %p(#PLOTPTR)=4
  PROC setSeed(%s)

  ; clear any blocks already on the board
  %c=100
  REPEAT
    %c=%c-1
    %i=% BANK #BANKLIB PEEK c
    IF %i < 255 THEN SPRITE %c+1,,,,0: ; only clear them if they're visible
  REPEAT UNTIL %c=0

  SPRITE PRINT 1

  IF #BANKDEBUG=0 THEN PROC loadBlocks(): ENDPROC

  ; DEBUG - repeat a game sequence
  ; source file is the submitted data structure from postHighScore
  LOAD "./DEBUG.BIN" BANK #BANKDEBUG

  ; seed
  %i=% BANK #BANKDEBUG DPEEK 0
  PROC setSeed(%i)

  ; length
  %l=% BANK #BANKDEBUG DPEEK 2

  PROC loadBlocks()
  LOCAL %i
  LOCAL %z
  FOR %z=%0 TO %(l-1)
    %i=% BANK #BANKDEBUG PEEK (z+4)
    PRINT AT 11,21;"BRICK ";%i;"@";%z;" "
    PROC selectBlock()
    PAUSE 10
  NEXT %z
ENDPROC

DEFPROC replayGame()
  PROC startGame(%p(#SEED))
ENDPROC

DEFPROC newGame()
  %s=%1+ RND $fffe

  PROC toHex(%s) TO s$

  BANK #BANKGFX_A LAYER #OFFSET_NEW_GAME_BOX TO 3,9,15,6
  INK 252: ; priority black
  PAPER 250: ; light grey background
  PRINT CHR$ 29;1; CHR$ 28;1; : ; turn on big
  PRINT AT 12,6;s$; CHR$ 138

  %i=0
  ; wait until the key is clear
  REPEAT : REPEAT UNTIL INKEY$ =""
  %j=14: ; %j is the character print offset on the X axis (max: 14, min: 6 - char width: 2)
  c$=s$
  REPEAT
    i$= INKEY$

    %c= CODE i$
    ; del key
    IF %c=12 THEN PRINT AT 12,%j;" ":%j=%j-2
    IF %j < 6 THEN %j=6
    IF %c=12 THEN j=%j:c$=c$(1 TO ((j/2)-3)): ; adjust the string if we deleted

    PROC tryToPrintChr()

    IF i$ <> "" THEN INK 252: ELSE : IF %i THEN INK 250: ELSE INK 252
    PRINT AT 12,%j; CHR$ 138
    %i=%(i+1) MOD 2

    PAUSE 36
  REPEAT UNTIL %c=13: ; return key

  ; clear the area that had the seed entry box
  LAYER ERASE 24,72,120,48

  ; reset font sizes
  PRINT CHR$ 29;0; CHR$ 28;0; : ; turn off big
  INK 255: PAPER 0

  PROC fromHex(c$) TO %s: ; convert the text to a numeric value
  IF %s=0 THEN %s=1

  PROC startGame(%s)
ENDPROC

DEFPROC tryToPrintChr()
  IF %c < $30 THEN ENDPROC : ; numeric lower
  IF %c > $66 THEN ENDPROC : ; alpha upper

  IF %(c > $39) AND (c < $61) THEN ENDPROC : ; in between

  IF (c$="000") AND (i$="0") THEN ENDPROC : ; prevent 0000

  IF %j=14 THEN ENDPROC : ; no room left
  c=%c
  INK 252
  PRINT AT 12,%j; CHR$ c
  c$=c$+ CHR$ c
  %j=%j+2
ENDPROC

DEFPROC loadBlocks()
  %p(#BLOCKSLEFT)=100

  INK 255
  PROC pad4(%p(#SCORE)) TO s$: PRINT AT 2,21;"SCORE ";s$;%p(#SCORE)

  INK 50
  PRINT AT 3,21;"CLEARED   0"
  PROC pad2(%p(#PLOTPTR)-2) TO s$: PRINT AT 4,21;"MOVES   ";s$;%(p(#PLOTPTR)-4)
  PROC pad2(%p(#BLOCKSLEFT)) TO s$: PRINT AT 5,21;"REMAIN  ";s$;%p(#BLOCKSLEFT)

  INK 255
  PROC pad4(%p(#LEVEL)) TO s$
  PRINT AT 7,21;"LEVEL ";s$;%p(#LEVEL)

  PROC printSeed()

  BANK #BANKGFX_A LAYER #OFFSET_CONTROLS TO 21,13,11,8

  ; call PopulateGrid
  %n=% BANK #BANKLIB USR #M_FN_POPULATEGRID

  PROC captureUndo()

  IF %p(#LOAD_PATTERN)=6 THEN RESTORE :%p(#LOAD_PATTERN)=0
  %p(#LOAD_PATTERN)=%p(#LOAD_PATTERN)+1

  ; configure the tiles (note that tile 4 is actually blank)
  BANK #BANK_TILES POKE 0,%p(#THEME),%p(#THEME)+1,%p(#THEME)+2,%p(#THEME)+3

  ; this uses a predefined order to render the blocks in a circle which makes
  ; for a nice effect
  %n=100
  REPEAT
    %n=%n-1
    READ %j
    %r=% BANK #BANKLIB PEEK j
    PROC toXY(%j) TO %x,%y
    SPRITE %j+1,%(x*16)+32,%(y*16)+48,%r+p(#THEME),1
    %a[j]=%r
    IF %n > 50 THEN PAUSE 1
  REPEAT UNTIL %n=0

  PROC pointerStatus(1)
ENDPROC

DEFPROC toXY(%n)
  %x=%n MOD 10
  %y=%n/10
ENDPROC =%x,%y

DEFPROC setSeed(%s)
  BANK #BANKLIB DPOKE %#M_RANDOMSEED,%s
  %p(#SEED)=%s
ENDPROC

DEFPROC printSeed()
  %s=%p(#SEED)
  PROC toHex(%s) TO s$
  INK 50
  PRINT AT 8,21;"SEED  #";s$
  PROC pad4(%p(#BEST)) TO s$
  PRINT AT 9,21;"BEST  ";s$;%p(#BEST)
ENDPROC

DEFPROC pad4(%w)
  IF %w < 10 THEN ENDPROC ="    "
  IF %w < 100 THEN ENDPROC ="   "
  IF %w < 1000 THEN ENDPROC ="  "
  IF %w < 10000 THEN ENDPROC =" "
ENDPROC =""

DEFPROC pad2(%w)
  IF %w < 10 THEN ENDPROC ="  "
  IF %w < 100 THEN ENDPROC =" "
ENDPROC =""

DEFPROC font(%i,width)
  BANK #BANK_FONTS COPY %(i*768),768 TO 0,14848
  PRINT CHR$ 30; CHR$ width;
ENDPROC

DEFPROC extractAssets()
  IF TESTING THEN PROC testLoadBanks(): ELSE : GO SUB 9900
ENDPROC

DEFPROC loadAssets()
  PROC extractAssets()
  ; I want to show the user some progress as soon as possible, so the first
  ; thing I do is clear the screen (and border) to black.
  BORDER 0: PAPER 0: CLS

  ; Next comes the palette as I use custom colour set - once I've got _something_
  LAYER 2,1
  LAYER PALETTE 0 BANK #BANKPAL,0

  ; now configure the custom L1 palette where blink values are tweaked in a smart way
  ; and most importantly the L1 transparency is configured at this point
  PROC configureL1Pal()

  ; now - the first meaningful painting is done: the game border with the blocks
  PROC setGameBorder()

  ; now we carry on with asset loading
  SPRITE PALETTE 0 BANK #BANKPAL,0

  ; the bank_zero is used for clearing screen data - since LAYER ERASE doesn't
  ; work in cspect. The bank, at time of writing, is also using the remaining
  ; space in the palette bank
  BANK #BANK_ZEROS ERASE #OFFSET_ZEROS,%($3fff-(#OFFSET_ZEROS))

  PROC font(0,8)
  DPOKE 23606,63744: ; 64000-256 (256 = 8 * 32 control chars)
  PRINT CHR$ 2: ; trigger the font to also be loaded on layer 2

  BANK #BANK_UNDO ERASE %$AA

  PROC loadCustomTheme()

  SPRITE BANK #BANKSPR
  SPRITE BORDER 1

  LAYER 2,1
  BANK #BANKSPR COPY TO #BANK_TILE_SPR
  TILE BANK #BANK_TILE_SPR
  TILE DIM #BANK_TILES,0,1,16

  ; set the default tile to the solid black at 54
  BANK #BANK_TILES ERASE 54
  BANK #BANK_TILES POKE 0,%p(#THEME),%p(#THEME)+1,%p(#THEME)+2,%p(#THEME)+3
  LAYER 1,1

  PROC installFX()
  DRIVER #DRV_FX,1,#BANK_FX

  ; just install all the drivers and maybe it'll be fine!
  PROC installMouse()
  PROC installInput()
  SPRITE #POINTER,96,72,#POINTERSPR,1

  BANK #BANK_LOCAL_SETTINGS ERASE
  LOAD "marbles.dat" BANK #BANK_LOCAL_SETTINGS
  PROC restoreSettings()

  POKE 23658,0: ; turn off CAPS LOCK (for menu items)
ENDPROC

DEFPROC loadCustomTheme()
  ON ERROR ENDPROC

  LOAD "theme.spr" BANK #BANK_CUSTOM_THEME,0,1024

  BANK #BANK_CUSTOM_THEME COPY 0,1024 TO #BANKSPR,10240
  %p(#CUSTOM_THEME)=1
ENDPROC

DEFPROC configureL1Pal()
  ; load L1 with our palette, but make a small tweak
  LAYER 1,1
  LAYER PALETTE 0,0,0: ; ink @ 0 = black (default)
  LAYER PALETTE 0,1,511: ; ink @ 1 = white
  LAYER PALETTE 0,2,511: ; ink @ 2 = white
  LAYER PALETTE 0,3,292: ; ink @ 3 = grey
  LAYER PALETTE 0,7,455: ; transparent @ 7
  LAYER PALETTE 0,23,455: ; paper black @ 7
  LAYER PALETTE 0,17,0: ; paper @ 1
  LAYER PALETTE 0,18,146: ; paper @ 2 = dark grey
  LAYER PALETTE 0,19,146: ; paper @ 3 = dark grey

  LAYER PALETTE 0,4,63: ; ink @ 4 = blue

  PALETTE OVER 0: ; L1 transparency @ 0 (black)
  PAPER 1: ; black background
ENDPROC

DEFPROC reset()
  SPRITE PRINT 0
  SPRITE CLEAR
  LAYER CLEAR
  PALETTE CLEAR
  LAYER 0
  CLS
ENDPROC

##########################################
# Joystick 1 callback procedures
# - MUST use these exactly procedure names
##########################################
DEFPROC U1()
  LOCAL %y
  %y=% SPRITE AT (#POINTER,1)
  IF %y > 1 THEN SPRITE #POINTER,,%y-2,,,
ENDPROC
DEFPROC L1()
  LOCAL %x
  %x=% SPRITE AT (#POINTER,0)
  IF %x > 1 THEN SPRITE #POINTER,%x-2,,,,
ENDPROC
DEFPROC D1()
  LOCAL %y
  %y=% SPRITE AT (#POINTER,1)
  IF %y < (256-1) THEN SPRITE #POINTER,,%y+2,,,
ENDPROC
DEFPROC R1()
  LOCAL %x
  %x=% SPRITE AT (#POINTER,0)
  IF %x < (320-1) THEN SPRITE #POINTER,%x+2,,,,
ENDPROC
DEFPROC F1()
  PROC select()
ENDPROC
DEFPROC F2()
ENDPROC
DEFPROC F3()
ENDPROC

DEFPROC onAnyKey()
  REPEAT : REPEAT UNTIL INKEY$ =""
  REPEAT : REPEAT UNTIL INKEY$ <> "" OR ( IN 31=16)
  REPEAT : REPEAT UNTIL INKEY$ =""
ENDPROC

DEFPROC untilKeyUp()
  REPEAT : REPEAT UNTIL INKEY$ =""
ENDPROC

; inside out
DATA %54,%55,%45,%44,%43,%53,%63,%64,%65,%66,%56,%46,%36,%35,%34,%33,%32,%42,%52,%62,%72,%73,%74,%75,%76
DATA %77,%67,%57,%47,%37,%27,%26,%25,%24,%23,%22,%21,%31,%41,%51,%61,%71,%81,%82,%83,%84,%85,%86,%87,%88
DATA %78,%68,%58,%48,%38,%28,%18,%17,%16,%15,%14,%13,%12,%11,%10,%20,%30,%40,%50,%60,%70,%80,%90,%91,%92
DATA %93,%94,%95,%96,%97,%98,%99,%89,%79,%69,%59,%49,%39,%29,%19,%9,%8,%7,%6,%5,%4,%3,%2,%1,%0

; zig zag
DATA %90,%91,%92,%93,%94,%95,%96,%97,%98,%99,%89,%88,%87,%86,%85,%84,%83,%82,%81,%80,%70,%71,%72,%73,%74
DATA %75,%76,%77,%78,%79,%69,%68,%67,%66,%65,%64,%63,%62,%61,%60,%50,%51,%52,%53,%54,%55,%56,%57,%58,%59
DATA %49,%48,%47,%46,%45,%44,%43,%42,%41,%40,%30,%31,%32,%33,%34,%35,%36,%37,%38,%39,%29,%28,%27,%26,%25
DATA %24,%23,%22,%21,%20,%10,%11,%12,%13,%14,%15,%16,%17,%18,%19,%9,%8,%7,%6,%5,%4,%3,%2,%1,%0

; rotated swipe
DATA %90,%80,%91,%70,%81,%92,%60,%71,%82,%93,%50,%61,%72,%83,%94,%40,%51,%62,%73,%84,%95,%30,%41,%52,%63
DATA %74,%85,%96,%20,%31,%42,%53,%64,%75,%86,%97,%10,%21,%32,%43,%54,%65,%76,%87,%98,%0,%11,%22,%33,%44,%55
DATA %66,%77,%88,%99,%1,%12,%23,%34,%45,%56,%67,%78,%89,%2,%13,%24,%35,%46,%57,%68,%79,%3,%14,%25,%36,%47
DATA %58,%69,%4,%15,%26,%37,%48,%59,%5,%16,%27,%38,%49,%6,%17,%28,%39,%7,%18,%29,%8,%19,%9

; outside in

DATA %0,%1,%2,%3,%4,%5,%6,%7,%8,%9,%19,%29,%39,%49,%59,%69,%79,%89,%99,%98,%97,%96,%95,%94,%93,%92,%91,%90
DATA %80,%70,%60,%50,%40,%30,%20,%10,%11,%12,%13,%14,%15,%16,%17,%18,%28,%38,%48,%58,%68,%78,%88,%87,%86
DATA %85,%84,%83,%82,%81,%71,%61,%51,%41,%31,%21,%22,%23,%24,%25,%26,%27,%37,%47,%57,%67,%77,%76,%75,%74
DATA %73,%72,%62,%52,%42,%32,%33,%34,%35,%36,%46,%56,%66,%65,%64,%63,%53,%43,%44,%45,%55,%54
 
; crawl
DATA %90,%80,%91,%70,%92,%82,%93,%95,%96,%72,%81,%94,%85,%97,%84,%98,%62,%99,%87,%75,%60,%71,%83,%88,%78
DATA %89,%74,%65,%86,%52,%73,%63,%76,%50,%61,%55,%79,%68,%66,%77,%45,%69,%59,%64,%54,%40,%51,%42,%32,%44
DATA %53,%49,%57,%67,%56,%35,%30,%41,%22,%34,%46,%58,%39,%48,%25,%36,%31,%20,%43,%21,%12,%10,%38,%47,%0
DATA %33,%15,%26,%29,%37,%24,%11,%2,%23,%16,%5,%19,%27,%14,%9,%1,%4,%28,%17,%13,%7,%6,%18,%3,%8
 
; two columns
DATA %90,%99,%80,%89,%70,%79,%60,%69,%50,%59,%40,%49,%30,%39,%20,%29,%10,%19,%0,%9,%91,%98,%81,%88,%71,%78
DATA %61,%68,%51,%58,%41,%48,%31,%38,%21,%28,%11,%18,%1,%8,%92,%97,%82,%87,%72,%77,%62,%67,%52,%57,%42,%47
DATA %32,%37,%22,%27,%12,%17,%2,%7,%93,%96,%83,%86,%73,%76,%63,%66,%53,%56,%43,%46,%33,%36,%23,%26,%13,%16
DATA %3,%6,%94,%95,%84,%85,%74,%75,%64,%65,%54,%55,%44,%45,%34,%35,%24,%25,%14,%15,%4,%5
 

# these lines need to numbered so that they can error and GOTO the right lines
# whereas in autoline I can't use GOTO. The error handler also sits at the root
# of the scope (i.e. not in a DEFPROC) so that I can cleanly get the error during
# debugging.
#autoline
9000 DEFPROC installMouse()
9010 ON ERROR GO TO 9030
9020 .uninstall /nextzxos/mouse.drv
9030 .install /nextzxos/mouse.drv
9040 ON ERROR
9050 ENDPROC

9060 DEFPROC installInput()
9070 ON ERROR GO TO 9100
9080 REM .uninstall /nextzxos/input.drv
9090 .install /nextzxos/input.drv
9100 ON ERROR
9110 ENDPROC

9120 DEFPROC installFX()
9130 ON ERROR GO TO 9160
9140 REM .uninstall /nextzxos/ayfx.drv
9150 .install /nextzxos/ayfx.drv
9160 ON ERROR
9170 ENDPROC


# error handling needs to be outside a proc
9200 ERROR TO err,lin,st
9210 e$= STR$ err
9220 ON ERROR
9230 LAYER 2,1
9240 PALETTE CLEAR
9250 LAYER CLEAR
9260 SPRITE CLEAR
9270 BORDER 7: INK 0: PAPER 7
9280 CLS
9290 SPRITE PRINT 0: ; turn off sprites
9300 PRINT "Error:";e$;", line:";lin;", statement:";st
9310 REPEAT : REPEAT UNTIL INKEY$ =""
9320 REPEAT : REPEAT UNTIL INKEY$ <> "" OR ( IN 31=16)
9330 REPEAT : REPEAT UNTIL INKEY$ ="": STOP

# generated via makefile
9900 .extract MARBLES.BAS +27648 512 -mb 15 : ; pal
9901 .extract MARBLES.BAS +28160 1536 -mb 29 : ; font
9902 .extract MARBLES.BAS +29696 15232 -mb 22 : ; gfx A
9903 .extract MARBLES.BAS +44928 15232 -mb 23 : ; gfx B
9904 .extract MARBLES.BAS +60160 8320 -mb 28 : ; gfx C
9905 .extract MARBLES.BAS +68480 1278 -mb 20 : ; lib
9906 .extract MARBLES.BAS +69758 16384 -mb 16 : ; sprites
9907 .extract MARBLES.BAS +86142 166 -mb 24 : ; fx
9909 ON ERROR GO TO 9911
9910 .extract MARBLES.BAS +135460 5968 -o /dot/http : ; .http
9911 ON ERROR GO TO 9913
9912 .extract MARBLES.BAS +141428 572 -o /nextzxos/ayfx.drv : ; ayfx.drv
9913 ON ERROR GO TO 9915
9914 .extract MARBLES.BAS +142000 578 -o /nextzxos/input.drv : ; input.drv
9990 ON ERROR : RETURN
