#autoline 1
#autostart 10
#program marbles

;-------------------------------------------------------------------------------
; VARIABLES
;
; %p() - player state
; i$   - input key
; s$   - temp printed string
;
;-------------------------------------------------------------------------------

RUN AT 3

ON ERROR GO TO 9200

#define BANKPAL=15
#define BANK_ZEROS=15
#define BANKSPR=16
#define BANK_TILE_SPR=17
#define BANK_TILES=18
#define BANKPLOT=19
#define BANKLIB=20
#define BANKGFX_A=22
#define BANKGFX_B=23
#define BANK_FX=24
#define BANK_REMOTE_SCORES=25
#define BANK_LOCAL_SCORES=26
#define BANK_UNDO=27
#define BANKGFX_C=28

#define DRV_FX=49

# plot data structure
# seed[2]
# moves_length[2]
# moves[...]
# name[3]

# high score structure
# name[3]
# seed[2]
# score[2]
# [...]

# set debug bank to non zero to load predefined sequence
#define BANKDEBUG=0

; bank graphic offsets
#define OFFSET_CONTROLS=0
#define OFFSET_NEW_GAME_BOX=5632
#define OFFSET_NEXT_LEVEL=11392
#define OFFSET_GAME_OVER=0
#define OFFSET_TITLE=2560

; entry points in the marbles.bin library for methods and method constants
#define M_CANMOVE=432
#define M_RANDOMSEED=434
#define M_FN_POPULATEGRID=454
#define M_TAGINDEX=499
#define M_FN_TAG=498
#define M_FN_MIXMAX=924

#define POINTER=127
#define POINTERSPR=63
#define COUNTER=126
#define FAKESPR=4

; user state
#define DEVICE=1
#define SCORE=2
#define BUSY=3
#define BLOCKSLEFT=4
#define BEST=5
#define THEME=6
#define PLOTPTR=7
#define SEED=8
#define LEVEL=9
#define LOAD_PATTERN=10
#define GOT_HIGH_SCORE=11
#define UNDO_PTR=12
#define LAST_CLEARED=13

#define MOUSE=1
#define JOYSTICK=2
#define KEYBAORD=3
#define NOT_SELECTED=4

#define EMPTY=54

%p(#DEVICE)=#NOT_SELECTED
%p(#SCORE)=0
%p(#THEME)=%5*5: ; or 2*5
RANDOMIZE
%p(#SEED)=%1+ RND $ffff
%p(#BEST)=0
%p(#UNDO_PTR)=0

h$="data.remysharp.com"

PROC reset()
PROC loadAssets()

; testing screens
; PROC installInput()
; PROC testSelectAnimation()
; PROC testGameOver()
; PROC splash()

PROC gameLoop()

PAUSE 0

DEFPROC testGameOver()
  PROC startGame(%p(#SEED))
  PROC gameOver()
  PROC debugStop()
ENDPROC

DEFPROC testSelectAnimation()
  %p(#SEED)=%$9999
  PROC startGame(%p(#SEED))
  SPRITE #POINTER,55,68,,,
  PROC select()
  PROC debugStop()
ENDPROC


DEFPROC gameLoop()
  REPEAT
;     PROC setGameBorder()
    PROC selectInput()
    %i=0
    PROC showHighScores() TO %i
    IF %i=0 THEN PROC replayGame(): ELSE : PROC startGame(%p(#SEED))

    REPEAT
      PROC readInput()
      IF i$="r" THEN PROC replayGame()
      IF i$="n" THEN PROC newGame()
      IF i$="u" THEN PROC undo()
    REPEAT UNTIL i$="e"
  REPEAT UNTIL 0
ENDPROC

DEFPROC splash()
  PROC printLayer()

  LAYER 2,1
  LOCAL %i

  ; just a little effect that makes the title text render from top and bottom
  ; at the same time (14 > i > 4)
  %i=13
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  %i=5
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  PAUSE 2
  %i=12
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  %i=6
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  PAUSE 2
  %i=11
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  %i=7
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  PAUSE 2
  %i=10
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  %i=7
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  PAUSE 2
  %i=9
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1
  %i=8
  BANK #BANKGFX_B LAYER %(#OFFSET_TITLE+(1408*(i-5))) TO 5,%i,22,1

  PROC debugStop()
ENDPROC

DEFPROC mainMenu()
  PROC printLayer()
  LOCAL %i
  LET start=0
  PROC printMainMenuOptions()
  PROC onAnyKey()
  %i=0
  REPEAT
    k$= INKEY$
    IF k$="1" THEN start=1
    IF (k$ > "3") THEN : ELSE : PROC showHighScores() TO %i: IF %i THEN PROC setSeed(%p(#SEED)):start=1: ELSE PROC printMainMenuOptions()
    IF k$="4" THEN PROC selectInput()
  REPEAT UNTIL start=1
ENDPROC


DEFPROC printMainMenuOptions()
  INK 1
  PRINT AT 5,8;"Select your input"
  DIM j$(4,18)
  j$(1)="1. Free play"
  j$(2)="2. Challenge"
  j$(3)="3. Highscores"
  j$(4)="4. Settings"

  CLS

  LAYER 1,1

  FOR %i=1 TO 4
    j=%i
    PRINT AT %(i*2)+8,7;j$(j)
  NEXT %i

ENDPROC

DEFPROC setGameBorder()
  PROC printLayer()
  CLS
  LAYER 2,1
  PAPER 254: INK 255
  LOAD "assets/welcome.nxi" LAYER
  LAYER 1,1
ENDPROC

DEFPROC showHighScores()
  b$= STR$ #BANK_REMOTE_SCORES
  ON ERROR ENDPROC =0: ; fixme - do some kind of error handling
  ../assets/http get -h h$ -u /6 -b b$ -7
  PROC renderHighScores() TO %i
ENDPROC =%i

DEFPROC renderHighScores()

  LOCAL %i: ; memory peek position
  LOCAL %j: ; screen print offset
  LOCAL %k: ; high score position (1..10)
  LOCAL %l: ; whether to print inverted
  PROC printLayer()

  CLS

  PAPER 1
  INK 2
  PRINT AT 5,11;"HIGH SCORES"

  %i=0
  %k=1
  %j=1
  REPEAT
    WHILE % BANK #BANK_REMOTE_SCORES PEEK i <> 0

    n$= BANK #BANK_REMOTE_SCORES PEEK$ (%i,3)
    %j=% BANK #BANK_REMOTE_SCORES DPEEK (i+3): ; seed
    PROC toHex(%j) TO s$
    %s=% BANK #BANK_REMOTE_SCORES DPEEK (i+5): ; score

    %i=%i+7

    PRINT AT %6+(i/7),%5-(k/10);

    PRINT %k;".";
    IF %l=0 THEN INK 2
    PRINT n$;
    IF %l=0 THEN INK 3
    PRINT "   #";s$;"    ";
    PROC pad4(%s) TO s$
    IF %l=0 THEN INK 2
    PRINT s$;%s
    %k=%k+1

  REPEAT UNTIL %i=0

  PRINT AT 19,7;"Challenge? "; FLASH 1;"Y"; FLASH 0;"es/No"
  PRINT AT 21,18;"▀"

  REPEAT
    k$= INKEY$
  REPEAT UNTIL k$="y" OR k$="n" OR ( CODE k$)=13
  REPEAT : REPEAT UNTIL INKEY$ =""

  IF k$="n" THEN PRINT AT 20,18;"   ▀": ENDPROC =0

  ; wait loop
  PRINT AT 19,4;"Use cursors keys & enter"
  PRINT AT 20,18;" "

  %i=0
  %j=%((i+7)*32)+6144
  FOR %k=%(j+4) TO %(j+26)
    %l=% BANK 5 PEEK k
    BANK 5 POKE %k,%(l^128)
  NEXT %k

  REPEAT
    k$= INKEY$
    %c= CODE k$
    IF %(c >= 9) AND (c <= 11) THEN PROC highlight(%c,%i) TO %i
  REPEAT UNTIL %c=13

  %p(#SEED)=% BANK #BANK_REMOTE_SCORES DPEEK ((i*7)+3): ; seed
ENDPROC =1

DEFPROC gameLayer()
  LAYER OVER 0
  LAYER 2,1
  PALETTE OVER 227
  CLS
ENDPROC

DEFPROC printLayer()
  LAYER OVER 0
  LAYER 1,1
  PALETTE OVER 0
ENDPROC

DEFPROC highlight(%c,%i)

  %j=%((i+7)*32)+6144
  FOR %k=%(j+4) TO %(j+26)
    %l=% BANK 5 PEEK k
    BANK 5 POKE %k,%(l^128)
  NEXT %k

  IF %c=11 THEN IF %i > 0 THEN %i=%i-1: ; up
  IF %c=8 THEN IF %i > 0 THEN %i=%i-1: ; left (aka up)
  IF %c=10 THEN IF %i < 9 THEN %i=%i+1: ; down
  IF %c=9 THEN IF %i < 9 THEN %i=%i+1: ; right (aka down)

  ; invert the row
  %j=%((i+7)*32)+6144
  FOR %k=%(j+4) TO %(j+26)
    %l=% BANK 5 PEEK k
    BANK 5 POKE %k,%(l^128)
  NEXT %k
ENDPROC =%i

DEFPROC selectInput()
  CLS

  LAYER 1,1

  ; settings loop
  PROC printSettings()
  LET start=0
  REPEAT
    k$= INKEY$
    IF k$="1" THEN %p(#DEVICE)=#MOUSE: PROC printSettings()
    IF k$="2" THEN %p(#DEVICE)=#JOYSTICK: PROC printSettings()
    IF k$="3" THEN %p(#DEVICE)=#KEYBAORD: PROC printSettings()

    IF k$="0" THEN start=1
    IF % IN 31=16 THEN %p(#DEVICE)=#JOYSTICK:start=1
  REPEAT UNTIL start=1

  SPRITE #POINTER,96,72,#POINTERSPR,1

  IF %p(#DEVICE)=#MOUSE THEN PROC installMouse()
  IF %p(#DEVICE) <> #MOUSE THEN PROC installInput()

  IF %(#DEVICE)=#JOYSTICK THEN DRIVER 125,2,3
  IF %(#DEVICE)=#KEYBAORD THEN DRIVER 125,2,5
ENDPROC

DEFPROC printSettings()
  INK 1
  PRINT AT 5,8;"Select your input"
  DIM j$(3,18)
  j$(1)="1. Mouse"
  j$(2)="2. Joystick"
  j$(3)="3. Keyboard (QAOP)"

  FOR %i=1 TO 3
    j=%i
    PRINT AT %(i*2)+8,7; INVERSE %i=p(#DEVICE);j$(j)
  NEXT %i
  INVERSE 0
  PRINT AT %i+13,7;"0. START!"
ENDPROC

DEFPROC readInput()
  i$= INKEY$
  IF %p(#DEVICE)=#MOUSE THEN PROC readMouse(): ELSE PROC readJoystick()
ENDPROC

DEFPROC readMouse()
  DRIVER 126,1 TO %b,%x,%y
  SPRITE #POINTER,%x/2,%y,,,
  IF %b&@111 THEN PROC select()
ENDPROC

DEFPROC readJoystick()
  DRIVER 125,4,1
  REM 12345678901234567890123456789012345678901234567890
ENDPROC

DEFPROC select()
  IF %p(#BUSY) THEN ENDPROC
  %i=%( SPRITE OVER (#POINTER,1 TO 100)): ; which block are we over when we selected

  ; colliding 0 sprite returns 128 (can't remember why though!)
  IF %i=128 THEN %i=0

  IF %i=0 THEN ENDPROC
  IF %i > 100 THEN ENDPROC : ; out of scope

  %i=%i-1
  PROC selectBlock()
ENDPROC

; %i = selected block
; Uses: %c, %i, %t
; Modifies: %p
DEFPROC selectBlock()
  IF %p(#BUSY) THEN ENDPROC

  %p(#BUSY)=1

  ; load %i into tagIndex
  BANK #BANKLIB POKE #M_TAGINDEX,%i
  ; call Tag()
  %t=% BANK #BANKLIB USR #M_FN_TAG

  ; %t contains the address of the number of blocks tagged (which is actually static)
  %c=% BANK #BANKLIB PEEK t

  IF %c < 2 THEN %p(#BUSY)=0: ENDPROC

  DRIVER #DRV_FX,2,1: ; play the "clack" sound

  %p(#SCORE)=%p(#SCORE)+(c*(5+c))
  %p(#LAST_CLEARED)=%c
  %p(#BLOCKSLEFT)=%p(#BLOCKSLEFT)-c
  BANK #BANKPLOT POKE %p(#PLOTPTR),%i: ; store the block cleared
  %p(#PLOTPTR)=%p(#PLOTPTR)+1
  BANK #BANKPLOT DPOKE 2,%p(#PLOTPTR)-4: ; add the count of moves to the data

  IF %p(#SCORE) > p(#BEST) THEN %p(#BEST)=%p(#SCORE):%p(#GOT_HIGH_SCORE)=1

  PROC captureUndo()

  ; clear the tagged blocks

  ; first commit them all as tiles
  ; then add new sprites as animations over those position
  ; fire the animation 3 times
  ; then empty them out

  %k=% BANK #BANKLIB USR #M_FN_MIXMAX
  %a=%(k >> 8)+1: ; min sprite id
  %b=%(k&$00FF)+1: ; max sprite id - required to disable later

  %k=0
  FOR %i=1 TO %c
    %j=% BANK #BANKLIB PEEK (t+i)
    %k=%j+1
    PROC toXY(%j) TO %x,%y
    %p=% SPRITE AT (k,2)
;     SPRITE %k,,,#EMPTY,
    SPRITE %k,,,51,
    TILE 1,1 AT 0,%p-p(#THEME) TO %x,%(y+1)
    SPRITE CONTINUE %k, STOP , STOP ,51 TO 54, BIN 01100000,10,0
  NEXT %i

;   PRINT AT 11,21;"DEBUG ";%a;"/";%b;"  "
;   PROC onAnyKey()
;   PRINT AT 11,21;"          "
;   PRINT AT 12,21;"          "

  ; animate the frames and then disable the sprite animation when it's done
  REPEAT
    SPRITE MOVE
    %i=% SPRITE AT (k,2)
  REPEAT UNTIL %i=54

  ; now disable the sprites that were animating
  SPRITE PAUSE %a TO %b

;   LAYER ERASE 0,0,80,80,0: ; breaks in cspect
  ; so instead we'll use the empty bytes in the palette bank and paint those
  BANK #BANK_ZEROS LAYER 512 TO 0,0,10,10

  INK 50
  PROC pad2(%c) TO s$
  PRINT AT 3,21;"CLEARED ";s$;%c
  PROC pad2(%p(#PLOTPTR)-4) TO s$
  PRINT AT 4,21;"MOVES   ";s$;%(p(#PLOTPTR)-4)
  PROC pad2(%p(#BLOCKSLEFT)) TO s$
  PRINT AT 5,21;"REMAIN  ";s$;%p(#BLOCKSLEFT)
  INK 255
  PROC pad4(%p(#SCORE)) TO s$
  PRINT AT 2,21;"SCORE ";s$;%p(#SCORE)

  ; now full render
  %c=100
  REPEAT
    %c=%c-1
    %i=% BANK #BANKLIB PEEK c
    IF %i < 255 THEN %i=%i+p(#THEME): ELSE %i=#EMPTY
    SPRITE %c+1,,,%i,
  REPEAT UNTIL %c=0

  %p(#BUSY)=0

  IF %( BANK #BANKLIB PEEK #M_CANMOVE)=0 THEN %p(#BUSY)=1: PAUSE 10: PROC gameOver()
  IF %p(#BLOCKSLEFT)=0 THEN PROC nextLevel()

ENDPROC

DEFPROC debugStop()
  REPEAT : REPEAT UNTIL INKEY$ <> ""
  STOP
ENDPROC

DEFPROC captureUndo()
  BANK #BANKLIB COPY 0,100 TO #BANK_UNDO,%p(#UNDO_PTR)
  BANK #BANK_UNDO DPOKE %(p(#UNDO_PTR)+100),%p(#SCORE),%p(#BLOCKSLEFT),%p(#LAST_CLEARED)
  %p(#UNDO_PTR)=%p(#UNDO_PTR)+106
ENDPROC

DEFPROC undo()
  IF %p(#UNDO_PTR) <= 106 THEN ENDPROC : ; no more undo
  IF %p(#BUSY) THEN ENDPROC

  LOCAL %o
  LOCAL %i
  LOCAL %c

  %p(#BUSY)=1

  ; this looks weird because it's 2 undo states, but it's because the tip is
  ; inclusive of the latest change, so moving back one state is 106 bytes, which
  ; is at the start of the current state, and once more takes us to the previous
  ; state, then we save the point to the end of that.
  %o=%p(#UNDO_PTR)-(106*2)

  ; reset undo position
  %p(#UNDO_PTR)=%(o+106)

  ; restore state
  BANK #BANK_UNDO COPY %o,100 TO #BANKLIB,0
  %p(#SCORE)=% BANK #BANK_UNDO DPEEK (o+100)
  %p(#BLOCKSLEFT)=% BANK #BANK_UNDO DPEEK (o+102)
  %p(#LAST_CLEARED)=% BANK #BANK_UNDO DPEEK (o+104)
  %p(#PLOTPTR)=%p(#PLOTPTR)-1
  BANK #BANKPLOT DPOKE 2,%(p(#PLOTPTR)-4)

  ; print game stats
  INK 255
  PROC pad4(%p(#SCORE)) TO s$
  PRINT AT 2,21;"SCORE ";s$;%p(#SCORE)
  INK 50

  PROC pad2(%p(#LAST_CLEARED)) TO s$
  PRINT AT 3,21;"CLEARED ";s$;%p(#LAST_CLEARED)

  PROC pad2(%p(#PLOTPTR)-4) TO s$
  PRINT AT 4,21;"MOVES   ";s$;%(p(#PLOTPTR)-4)
  PROC pad2(%p(#BLOCKSLEFT)) TO s$
  PRINT AT 5,21;"REMAIN  ";s$;%p(#BLOCKSLEFT)

  ; render
  %c=100
  REPEAT
    %c=%c-1
    %i=% BANK #BANKLIB PEEK c
    IF %i < 255 THEN %i=%i+p(#THEME): ELSE %i=#EMPTY
    SPRITE %c+1,,,%i,
  REPEAT UNTIL %c=0

  %p(#BUSY)=0
ENDPROC

DEFPROC gameOver()
  LOCAL %i
  LOCAL %j
  %i=0
  %j=0
  i$=""

  ; play a gameover sound
;   DRIVER #DRV_FX,2,0

  ; save their last game to disk
  n$="REM"
  BANK #BANKPLOT POKE %p(#PLOTPTR),n$
  %p(#PLOTPTR)=%p(#PLOTPTR)+3
  %p(#BUSY)=1
  SAVE "last.bnk" BANK #BANKPLOT,0,%p(#PLOTPTR)
  IF %p(#GOT_HIGH_SCORE) THEN PROC postHighScore()

  %p(0)=%$1ff
  %p(1)=%$124
  %p(2)=%$1f8
  %p(3)=%$145
  BANK #BANKGFX_B LAYER #OFFSET_GAME_OVER TO 6,22,20,2
  REPEAT
    ; this rotates the "game over" text as a layer draw - though it should be a
    ; palette rotation which would be hugely faster
    IF %j&7=0 THEN :%i=%(i+1) MOD 4: LAYER PALETTE 0,136,%p(i)
    %j=%j+1
    PROC readInput(): ; i$ is assigned in readInput
  REPEAT UNTIL (i$="r") OR (i$="n") OR (i$="e")

  %p(#BUSY)=0

  ; clear the section that showed game over
  BANK 11 ERASE 12288,4096,0

ENDPROC

DEFPROC postHighScore()
  ; TODO prompt for name - limit 3
  l=%p(#PLOTPTR)
  l$= STR$ l
  b$= STR$ #BANKPLOT

;   ON ERROR ENDPROC

  ; post to data.remysharp.com/6 - flash with white and base64 encode
  ../assets/http post -b b$ -l l$ -h h$ -u /6 -v 7 -7
ENDPROC

; param {int} %i
; returns {string} hex string
; uses: %j, h$, r$, p
DEFPROC toHex(%i)
  LOCAL %j
  LOCAL h$
  LOCAL r$
  LOCAL p
  %j=4: ; symbols (2 bytes = 4 symbols)
  h$="0123456789abcdef"
  r$=""
  REPEAT : WHILE %j <> 0
    %j=%j-1
    p=%(i&$f)+1
    r$=h$(p)+r$
    %i=%i >> 4
  REPEAT UNTIL 0
ENDPROC =r$

DEFPROC fromHex(s$)
  LOCAL i: ; counter (since we need to splice)
  LOCAL %j: ; int value for i
  LOCAL %l: ; string length
  LOCAL %r: ; return value
  LOCAL c$: ; current char
  LOCAL %i: ; numeric value of current char

  %l= LEN (s$)

  %r=0

  FOR i=%l TO 1 STEP -1
    c$=s$(i TO i)
    %i= CODE c$
    IF %i > $46 THEN %i=%i-$20: ; to uppercase
    IF %i > $39 THEN %i=%i-$37: ELSE %i=%i-$30: ; to number

    %j=i
    %r=%r+((i)*(1 << ((l-j)*4)))
;     PRINT c$;"-";%i;"-";%1 << ((l-j)*4)
  NEXT i
ENDPROC =%r

DEFPROC nextLevel()
  %p(#LEVEL)=%p(#LEVEL)+1
  %p(#UNDO_PTR)=0: ; reset the undo

  ; show Next Level box
  BANK #BANKGFX_A LAYER #OFFSET_NEXT_LEVEL TO 5,9,10,6

  SPRITE #COUNTER,97,116,58,1, BIN 0,1,1
  SPRITE #COUNTER-1,97,116,62,1, BIN 0,1,1: ; put a sprite under the countdown that's solid white, just in case we hide the counter before we clear the screen
  SPRITE CONTINUE #COUNTER, STOP , STOP ,58 TO 61, BIN 01100000,60,60: ; count down effect

  REPEAT
    SPRITE MOVE INT
  REPEAT UNTIL % SPRITE #COUNTER=0

  SPRITE #COUNTER-1,,,,0: ; remove the backing sprite

  ; remove only the "new level" box that we painted
  LAYER ERASE 40,72,80,48
  PROC printSeed()
  PROC loadBlocks()
ENDPROC

DEFPROC startGame(%s)
  CLS
  PROC gameLayer()
  SPRITE PRINT 0
  %p(#LEVEL)=1
  %p(#SCORE)=0
  %p(#BUSY)=0
  %p(#LAST_CLEARED)=0
  %p(#UNDO_PTR)=0
  %p(#GOT_HIGH_SCORE)=0
  BANK #BANKPLOT ERASE %$7f
  BANK #BANKPLOT DPOKE 0,%s: ; first 16bit word is the seed
  %p(#PLOTPTR)=4
  PROC setSeed(%s)

  ; clear any blocks already on the board
  %c=100
  REPEAT
    %c=%c-1
    %i=% BANK #BANKLIB PEEK c
    IF %i < 255 THEN SPRITE %c+1,,,,0: ; only clear them if they're visible
  REPEAT UNTIL %c=0

  SPRITE PRINT 1

  IF #BANKDEBUG=0 THEN PROC loadBlocks(): ENDPROC

  ; DEBUG - repeat a game sequence
  ; source file is the submitted data structure from postHighScore
  LOAD "./DEBUG.BIN" BANK #BANKDEBUG

  ; seed
  %i=% BANK #BANKDEBUG DPEEK 0
  PROC setSeed(%i)

  ; length
  %l=% BANK #BANKDEBUG DPEEK 2

  PROC loadBlocks()
  LOCAL %i
  LOCAL %z
  FOR %z=%0 TO %(l-1)
    %i=% BANK #BANKDEBUG PEEK (z+4)
    PRINT AT 11,21;"BRICK ";%i;"@";%z;" "
    PROC selectBlock()
    PAUSE 10
  NEXT %z
ENDPROC

DEFPROC replayGame()
  PROC startGame(%p(#SEED))
ENDPROC

DEFPROC newGame()
  %s=%1+ RND $fffe

  PROC toHex(%s) TO s$

  BANK #BANKGFX_A LAYER #OFFSET_NEW_GAME_BOX TO 3,9,15,6
  INK 252: ; priority black
  PAPER 250: ; light grey background
  PRINT CHR$ 29;1; CHR$ 28;1; : ; turn on big
  PRINT AT 12,6;s$; CHR$ 138

  %i=0
  ; wait until the key is clear
  REPEAT : REPEAT UNTIL INKEY$ =""
  %j=14: ; %j is the character print offset on the X axis (max: 14, min: 6 - char width: 2)
  c$=s$
  REPEAT
    i$= INKEY$

    %c= CODE i$
    ; del key
    IF %c=12 THEN PRINT AT 12,%j;" ":%j=%j-2
    IF %j < 6 THEN %j=6
    IF %c=12 THEN j=%j:c$=c$(1 TO ((j/2)-3)): ; adjust the string if we deleted

    PROC tryToPrintChr()

    IF i$ <> "" THEN INK 252: ELSE : IF %i THEN INK 250: ELSE INK 252
    PRINT AT 12,%j; CHR$ 138
    %i=%(i+1) MOD 2

    PAUSE 36
  REPEAT UNTIL %c=13: ; return key

  LAYER ERASE 24,72,120,48

  ; reset font sizes
  PRINT CHR$ 29;0; CHR$ 28;0; : ; turn off big
  INK 255: PAPER 0

  PROC fromHex(c$) TO %s: ; convert the text to a numeric value
  IF %s=0 THEN %s=1

  PROC startGame(%s)
ENDPROC

DEFPROC tryToPrintChr()
  IF %c < $30 THEN ENDPROC : ; numeric lower
  IF %c > $66 THEN ENDPROC : ; alpha upper

  IF %(c > $39) AND (c < $61) THEN ENDPROC : ; in between

  IF (c$="000") AND (i$="0") THEN ENDPROC : ; prevent 0000

  IF %j=14 THEN ENDPROC : ; no room left
  c=%c
  INK 252
  PRINT AT 12,%j; CHR$ c
  c$=c$+ CHR$ c
  %j=%j+2
ENDPROC

DEFPROC loadBlocks()
  %p(#BLOCKSLEFT)=100

  INK 50

  PRINT AT 3,21;"CLEARED   0"
  PROC pad2(%p(#PLOTPTR)-2) TO s$
  PRINT AT 4,21;"MOVES   ";s$;%(p(#PLOTPTR)-4)
  PROC pad2(%p(#BLOCKSLEFT)) TO s$
  PRINT AT 5,21;"REMAIN  ";s$;%p(#BLOCKSLEFT)
  INK 255
  PROC pad4(%p(#SCORE)) TO s$
  PRINT AT 2,21;"SCORE ";s$;%p(#SCORE)

  PROC pad4(%p(#LEVEL)) TO s$
  PRINT AT 7,21;"LEVEL ";s$;%p(#LEVEL)

  BANK #BANKGFX_A LAYER #OFFSET_CONTROLS TO 21,13,11,8

  ; call PopulateGrid
  %n=% BANK #BANKLIB USR #M_FN_POPULATEGRID

  PROC captureUndo()

  IF %p(#LOAD_PATTERN)=6 THEN RESTORE :%p(#LOAD_PATTERN)=0
  %p(#LOAD_PATTERN)=%p(#LOAD_PATTERN)+1

  ; configure the tiles
  BANK #BANK_TILES POKE 0,%p(#THEME),%p(#THEME)+1,%p(#THEME)+2,%p(#THEME)+3

  ; this uses a predefined order to render the blocks in a circle which makes
  ; for a nice effect
  %n=100
  REPEAT
    %n=%n-1
    READ %j
    %r=% BANK #BANKLIB PEEK j
    PROC toXY(%j) TO %x,%y
    SPRITE %j+1,%(x*16)+32,%(y*16)+48,%r+p(#THEME),1
    %a[j]=%r
    IF %n > 50 THEN PAUSE 1
  REPEAT UNTIL %n=0
ENDPROC

DEFPROC toXY(%n)
  %x=%n MOD 10
  %y=%n/10
ENDPROC =%x,%y

DEFPROC setSeed(%s)
  BANK #BANKLIB DPOKE %#M_RANDOMSEED,%s
  %p(#SEED)=%s
  PROC printSeed()
ENDPROC

DEFPROC printSeed()
  %s=%p(#SEED)
  PROC toHex(%s) TO s$
  INK 50
  PRINT AT 8,21;"SEED  #";s$
  PROC pad4(%p(#BEST)) TO s$
  PRINT AT 9,21;"BEST  ";s$;%p(#BEST)
ENDPROC

DEFPROC pad4(%w)
  IF %w < 10 THEN ENDPROC ="    "
  IF %w < 100 THEN ENDPROC ="   "
  IF %w < 1000 THEN ENDPROC ="  "
  IF %w < 10000 THEN ENDPROC =" "
ENDPROC =""

DEFPROC pad2(%w)
  IF %w < 10 THEN ENDPROC ="  "
  IF %w < 100 THEN ENDPROC =" "
ENDPROC =""

DEFPROC loadAssets()
  ; show the border right away
  BORDER 0: PAPER 0: CLS
  ; shadow L2 ends at 14, so we start at 15
  LAYER 2,1
  BANK #BANKPAL ERASE
  LOAD "assets/marbles.pal" BANK #BANKPAL
  LAYER PALETTE 0 BANK #BANKPAL,0

  PROC configureL1Pal()
  PROC setGameBorder()
  SPRITE PALETTE 0 BANK #BANKPAL,0

  LOAD "./assets/font.bin" CODE 64000
  DPOKE 23606,63744: ; 64000-256 (256 = 8 * 32 control chars)
  PRINT CHR$ 2: ; trigger the font to also be loaded on layer 2

  LOAD "assets/controls.nxi" BANK #BANKGFX_A,#OFFSET_CONTROLS,5632: ; 88w
  LOAD "assets/new-game.nxi" BANK #BANKGFX_A,#OFFSET_NEW_GAME_BOX,5760: ; 120w
  LOAD "assets/next-level-small.nxi" BANK #BANKGFX_A,#OFFSET_NEXT_LEVEL,3840: ; 80w
  LOAD "assets/game-over.nxi" BANK #BANKGFX_B,#OFFSET_GAME_OVER,2560: ; 160w
  LOAD "assets/title.nxi" BANK #BANKGFX_B,#OFFSET_TITLE,12672: ; 176w

  ; marbles library
  LOAD "assets/marbles.bin" BANK #BANKLIB

  BANK #BANK_UNDO ERASE %$AA

  LOAD "assets/marbles.spr" BANK #BANKSPR
  SPRITE BANK #BANKSPR
  SPRITE BORDER 1

  LAYER 2,1
  BANK #BANKSPR COPY TO #BANK_TILE_SPR
  TILE BANK #BANK_TILE_SPR
  TILE DIM #BANK_TILES,0,1,16
  LAYER 1,1

  PROC installFX()
  LOAD "assets/marbles.afb" BANK #BANK_FX
  DRIVER #DRV_FX,1,#BANK_FX

  POKE 23658,0: ; turn off CAPS LOCK (for menu items)
ENDPROC

DEFPROC configureL1Pal()
  ; load L1 with our palette, but make a small tweak
  LAYER 1,1
  LAYER PALETTE 0,0,0: ; ink @ 0 = black (default)
  LAYER PALETTE 0,1,511: ; ink @ 1 = white
  LAYER PALETTE 0,2,511: ; ink @ 2 = white
  LAYER PALETTE 0,3,292: ; ink @ 3 = grey
  LAYER PALETTE 0,7,455: ; transparent @ 7
  LAYER PALETTE 0,23,455: ; paper black @ 7
  LAYER PALETTE 0,17,0: ; paper @ 1
  LAYER PALETTE 0,18,146: ; paper @ 2 = dark grey
  LAYER PALETTE 0,19,146: ; paper @ 3 = dark grey
  PALETTE OVER 0: ; L1 transparency @ 0 (black)
  PAPER 1: ; black background
ENDPROC

DEFPROC reset()
  SPRITE PRINT 0
  SPRITE CLEAR
  LAYER CLEAR
  PALETTE CLEAR
  LAYER 0
  CLS
ENDPROC

##########################################
# Joystick 1 callback procedures
# - MUST use these exactly procedure names
##########################################
DEFPROC U1()
  LOCAL %y
  %y=% SPRITE AT (#POINTER,1)
  IF %y > 1 THEN SPRITE #POINTER,,%y-2,,,
ENDPROC
DEFPROC L1()
  LOCAL %x
  %x=% SPRITE AT (#POINTER,0)
  IF %x > 1 THEN SPRITE #POINTER,%x-2,,,,
ENDPROC
DEFPROC D1()
  LOCAL %y
  %y=% SPRITE AT (#POINTER,1)
  IF %y < (256-1) THEN SPRITE #POINTER,,%y+2,,,
ENDPROC
DEFPROC R1()
  LOCAL %x
  %x=% SPRITE AT (#POINTER,0)
  IF %x < (320-1) THEN SPRITE #POINTER,%x+2,,,,
ENDPROC
DEFPROC F1()
  PROC select()
ENDPROC
DEFPROC F2()
  PROC select()
ENDPROC
DEFPROC F3()
  PROC select()
ENDPROC

DEFPROC onAnyKey()
  REPEAT : REPEAT UNTIL INKEY$ =""
  REPEAT : REPEAT UNTIL INKEY$ <> "" OR ( IN 31=16)
  REPEAT : REPEAT UNTIL INKEY$ =""
ENDPROC

; inside out
DATA 54,55,45,44,43,53,63,64,65,66,56,46,36,35,34,33,32,42,52,62,72,73,74,75,76,77,67,57,47,37,27,26,25,24,23,22,21,31,41,51,61,71,81,82,83,84,85,86,87,88,78,68,58,48,38,28,18,17,16,15,14,13,12,11,10,20,30,40,50,60,70,80,90,91,92,93,94,95,96,97,98,99,89,79,69,59,49,39,29,19,9,8,7,6,5,4,3,2,1,0

; zig zag
DATA 90,91,92,93,94,95,96,97,98,99,89,88,87,86,85,84,83,82,81,80,70,71,72,73,74,75,76,77,78,79,69,68,67,66,65,64,63,62,61,60,50,51,52,53,54,55,56,57,58,59,49,48,47,46,45,44,43,42,41,40,30,31,32,33,34,35,36,37,38,39,29,28,27,26,25,24,23,22,21,20,10,11,12,13,14,15,16,17,18,19,9,8,7,6,5,4,3,2,1,0

; rotated swipe
DATA 90,80,91,70,81,92,60,71,82,93,50,61,72,83,94,40,51,62,73,84,95,30,41,52,63,74,85,96,20,31,42,53,64,75,86,97,10,21,32,43,54,65,76,87,98,0,11,22,33,44,55,66,77,88,99,1,12,23,34,45,56,67,78,89,2,13,24,35,46,57,68,79,3,14,25,36,47,58,69,4,15,26,37,48,59,5,16,27,38,49,6,17,28,39,7,18,29,8,19,9

; outside in
DATA 0,1,2,3,4,5,6,7,8,9,19,29,39,49,59,69,79,89,99,98,97,96,95,94,93,92,91,90,80,70,60,50,40,30,20,10,11,12,13,14,15,16,17,18,28,38,48,58,68,78,88,87,86,85,84,83,82,81,71,61,51,41,31,21,22,23,24,25,26,27,37,47,57,67,77,76,75,74,73,72,62,52,42,32,33,34,35,36,46,56,66,65,64,63,53,43,44,45,55,54

; crawl
DATA 90,80,91,70,92,82,93,95,96,72,81,94,85,97,84,98,62,99,87,75,60,71,83,88,78,89,74,65,86,52,73,63,76,50,61,55,79,68,66,77,45,69,59,64,54,40,51,42,32,44,53,49,57,67,56,35,30,41,22,34,46,58,39,48,25,36,31,20,43,21,12,10,38,47,0,33,15,26,29,37,24,11,2,23,16,5,19,27,14,9,1,4,28,17,13,7,6,18,3,8

; two columns
DATA 90,99,80,89,70,79,60,69,50,59,40,49,30,39,20,29,10,19,0,9,91,98,81,88,71,78,61,68,51,58,41,48,31,38,21,28,11,18,1,8,92,97,82,87,72,77,62,67,52,57,42,47,32,37,22,27,12,17,2,7,93,96,83,86,73,76,63,66,53,56,43,46,33,36,23,26,13,16,3,6,94,95,84,85,74,75,64,65,54,55,44,45,34,35,24,25,14,15,4,5

# these lines need to numbered so that they can error and GOTO the right lines
# whereas in autoline I can't use GOTO. The error handler also sits at the root
# of the scope (i.e. not in a DEFPROC) so that I can cleanly get the error during
# debugging.
#autoline
9000 DEFPROC installMouse()
9010 ON ERROR GO TO 9030
9020 .uninstall /nextzxos/mouse.drv
9030 .install /nextzxos/mouse.drv
9040 ON ERROR
9050 ENDPROC

9060 DEFPROC installInput()
9061 ;SPRITE #POINTER,96,72,#POINTERSPR,1
9070 ON ERROR GO TO 9090
9080 .uninstall assets/input.drv
9090 .install assets/input.drv
9100 ON ERROR
9110 ENDPROC

9120 DEFPROC installFX()
9130 ON ERROR GO TO 9150
9140 .uninstall assets/ayfx.drv
9150 .install assets/ayfx.drv
9160 ON ERROR
9170 ENDPROC


# error handling needs to be outside a proc
9200 ERROR TO err,lin,st
9210 e$= STR$ err
9220 ON ERROR
9230 LAYER 2,1
9240 PALETTE CLEAR
9250 LAYER CLEAR
9260 SPRITE CLEAR
9270 BORDER 7: INK 0: PAPER 7
9280 CLS
9290 SPRITE PRINT 0: ; turn off sprites
9300 PRINT "Error:";e$;", line:";lin;", statement:";st
9310 REPEAT : REPEAT UNTIL INKEY$ =""
9320 REPEAT : REPEAT UNTIL INKEY$ <> "" OR ( IN 31=16)
9330 REPEAT : REPEAT UNTIL INKEY$ =""

