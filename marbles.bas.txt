#autoline 10
#autostart 10
#program marbles

RUN AT 3

#define BANKPAL=15
#define BANKSPR=16
#define BANKTILE=17

#define GRIDSTART=22

#define POINTER=127

#define DEVICE=1
#define SCORE=2
#define BUSY=3
#define BLOCKSLEFT=4
#define BEST=5

#define MOUSE=1
#define JOYSTICK=2
#define KEYBAORD=3

#define XMIN=0
#define XMAX=1
#define YMIN=2

%p(#DEVICE)=#KEYBAORD
%p(#SCORE)=0
%p(#BEST)=1036

PROC reset()
PROC loadAssets()
PROC selectInput()
PROC loadBlocks()
PROC mainLoop()

PAUSE 0

DEFPROC mainLoop()
  %i=0
  REPEAT
    PROC readInput()
    IF INKEY$ ="r" THEN PROC loadBlocks()
  REPEAT UNTIL 0
ENDPROC


DEFPROC selectInput()
  PAPER 254: INK 255: BORDER 0
;   CLS
  LOAD "assets/welcome.nxi" LAYER

  ; settings loop
  PROC printSettings()
  REPEAT
    k$= INKEY$
    IF k$="1" THEN %p(#DEVICE)=#MOUSE: PROC printSettings()
    IF k$="2" THEN %p(#DEVICE)=#JOYSTICK: PROC printSettings()
    IF k$="3" THEN %p(#DEVICE)=#KEYBAORD: PROC printSettings()
  REPEAT UNTIL k$="0"

  IF %p(#DEVICE)=#MOUSE THEN PROC installMouse(): DRIVER 126,2,#POINTER,12
  IF %p(#DEVICE) <> #MOUSE THEN PROC installInput(): SPRITE #POINTER,96,72,12,1

  IF %(#DEVICE)=#JOYSTICK THEN DRIVER 125,2,3
  IF %(#DEVICE)=#KEYBAORD THEN DRIVER 125,2,5

  CLS
ENDPROC

DEFPROC printSettings()
  PRINT AT 5,8;"Select your input"
  DIM j$(3,18)
  j$(1)="1. Mouse"
  j$(2)="2. Joystick"
  j$(3)="3. Keyboard (QAOP)"

  FOR %i=1 TO 3
    j=%i
    PRINT AT %(i*2)+8,7; INVERSE %i=p(#DEVICE);j$(j)
  NEXT %i
  INVERSE 0
  PRINT AT %i+13,7;"0. START!"
ENDPROC

DEFPROC readInput()
  IF %p(#DEVICE)=#MOUSE THEN PROC readMouse(): ELSE PROC readJoystick(): ENDPROC
ENDPROC

DEFPROC readMouse()
  DRIVER 126,1 TO %b,%x,%y
  IF %b&@111 THEN PROC selectBlock(%x,%y)
ENDPROC

DEFPROC readJoystick()
  DRIVER 125,4,1
  REM 12345678901234567890123456789012345678901234567890
ENDPROC

DEFPROC selectBlock()
  IF %p(#BUSY) THEN ENDPROC
  %p(#BUSY)=1

  %i=%( SPRITE OVER (#POINTER,0 TO 99))

  IF %i > 99 THEN %p(#BUSY)=0: ENDPROC : ; out of scope

  %x=%( SPRITE AT (i,0)-32) >> 4
  %y=%( SPRITE AT (i,1)-48) >> 4
  %b=%( SPRITE AT (i,2)): ; manual offset

  ;PRINT AT 22,0;"index: ";%i;" @ x/y:";%x;"/";%y;", block: ";%b;"    "

  IF %a[i]=0 THEN %p(#BUSY)=0: ENDPROC : ; empty block

  %c=0
  %c[c]=-1

  PROC tag(%b,%x,%y)

  IF %c < 2 THEN %p(#BUSY)=0: ENDPROC

  %p(#BLOCKSLEFT)=%p(#BLOCKSLEFT)-c
  %p(#SCORE)=%p(#SCORE)+(c*(5+c))

  INK 50
  PROC pad2(%c) TO s$
  PRINT AT 3,21;"CLEARED ";s$;%c
  PROC pad2(%p(#BLOCKSLEFT)) TO s$
  PRINT AT 4,21;"REMAIN  ";s$;%p(#BLOCKSLEFT)
  INK 255
  PROC pad4(%p(#SCORE)) TO s$
  PRINT AT 2,21;"SCORE ";s$;%p(#SCORE);""

  ; this helps me calculate the area to move blocks - which means less itterations
  %z(#XMIN)=9
  %z(#XMAX)=0
  %z(#YMIN)=0
  ; remove the selected blocks
  FOR %i=%0 TO %(c-1)
    SPRITE %c[i],,,0,
    %a[c[i]]=0

    PROC toXY(%c[i]) TO %x,%y
    IF %x < z(#XMIN) THEN %z(#XMIN)=%x
    IF %x > z(#XMAX) THEN %z(#XMAX)=%x
    IF %y > z(#YMIN) THEN %z(#YMIN)=%y

    ; allow UI to tick
    PROC readInput()
  NEXT %i

  %x=%z(#XMIN)
  %z(#XMAX)=%z(#XMAX)+1
  ; marginly faster than doing a FOR x TO loop
  REPEAT : WHILE %x <> z(#XMAX)
    %y=%z(#YMIN)
    REPEAT : WHILE %y <> -1
      %i=%(10*y)+x
      IF %a[i]=0 THEN PROC clearColumn(%i,%x,%y):%y=0: ; IF %f THEN %y=%y+1

      ; allow UI to tick
      PROC readInput()

      %y=%y-1
    REPEAT UNTIL 0
    %x=%x+1
  REPEAT UNTIL 0

  ; now collapse the columns
  %x=%z(#XMIN)
  %z=%0
  REPEAT : WHILE %x <> 10
    %i=%90+x
    IF %a[i]=0 THEN %z=%x: ELSE : IF %z THEN PROC shiftColumn(%x,%z):%z=0:%x=0
    %x=%x+1
  REPEAT UNTIL 0

  %p(#BUSY)=0
ENDPROC

DEFPROC shiftColumn(%x,%z)
  %y=%0
  REPEAT : WHILE %y < 10
    %a=%10*y
    %i=%a+x: ; left
    %j=%a+z: ; right

    %a=%a[i]
    %a[i]=%a[j]
    SPRITE %i,,,%a[j],
    %a[j]=%a
    SPRITE %j,,,%a,

    %y=%y+1
  REPEAT UNTIL 0

ENDPROC

DEFPROC clearColumn(%i,%x,%y)
;   SPRITE %i,,,1,1
  REPEAT
    %y=%y-1
    %t=%(10*y)+x

    WHILE %y <> -1: ; break

    ; if we hit a block, then swap it's position
    IF %a[t] THEN PROC clearColumnSwap()

    ; allow UI to tick
    PROC readInput()


;     PROC onAnyKey()
  REPEAT UNTIL 0
ENDPROC

; mutate values
DEFPROC clearColumnSwap()
;   PRINT AT 4,21;"SWAP ";%i;"-";%t;" "

  ; swap the blocks at %i and %t
  %a=%a[i]
  %a[i]=%a[t]
  SPRITE %i,,,%a[t],
  %a[t]=%a
  SPRITE %t,,,%a,

  ; cycle to the block directly above
  %i=%i-10
ENDPROC

DEFPROC tag(%b,%x,%y)

  IF %x > 9 THEN ENDPROC
  IF %y > 9 THEN ENDPROC

  %i=%(10*y)+x

  ;PRINT AT 21,0;"                    "

  IF %i > 99 THEN ENDPROC : ; out of bounds
  IF %b <> a[i] THEN ENDPROC : ; not a match

  %j=%0
  %t=%0

  ; array.includes?
  REPEAT
    IF %c THEN IF %c[j]=i THEN %t=%1
    ; allow UI to tick
    PROC readInput()
    %j=%j+1
  REPEAT UNTIL %(j >= c) OR (t=1)
  IF %t THEN ENDPROC

  %c[c]=%i

  IF %c THEN SPRITE %c[c],,,0,
  IF %c=1 THEN SPRITE %c[0],,,0,

  %c=%c+1


  ; allow UI to tick
  PROC readInput()

; now search for more
  PROC tag(%b,%x-1,%y)
  PROC tag(%b,%x+1,%y)
  PROC tag(%b,%x,%y-1)
  PROC tag(%b,%x,%y+1)

ENDPROC

; param {int} %i
; returns {string} hex string
; uses: %j, h$, r$, p
DEFPROC toHex(%i)
  %j=4: ; symbols (2 bytes = 4 symbols)
  h$="0123456789abcdef"
  r$=""
  REPEAT : WHILE %j <> 0
    %j=%j-1
    p=%(i&$f)+1
    r$=h$(p)+r$
    %i=%i >> 4
  REPEAT UNTIL 0
ENDPROC =r$

DEFPROC loadBlocks()
  %p(#SCORE)=0
  %p(#BLOCKSLEFT)=100
  PRINT AT 2,21;"SCORE    0"
  PROC setSeed(%1+ RND $ffff): ; FIXME this is a test

  %n=0
  REPEAT
    PROC pickRandom() TO %r
    PROC toXY(%n) TO %x,%y
    SPRITE %n,%(x*16)+32,%(y*16)+48,%(1 << r),0
    %a[n]=%1 << r
    %n=%n+1
  REPEAT UNTIL %n=100

  %n=0
  REPEAT
    SPRITE %n,,,,1
    %n=%n+1
  REPEAT UNTIL %n=100
ENDPROC

DEFPROC toXY(%n)
  %x=%n MOD 10
  %y=%n/10
ENDPROC =%x,%y

DEFPROC setSeed(%s)
  BANK 17 DPOKE %1,%s
  PROC toHex(%s) TO s$
  INK 50
  PRINT AT 7,21;"SEED #";s$
  INK 255
  PROC pad4(%p(#BEST)) TO s$
  PRINT AT 6,21;"BEST  ";s$;%p(#BEST)
ENDPROC

DEFPROC pad4(%w)
  IF %w < 10 THEN ENDPROC ="   "
  IF %w < 100 THEN ENDPROC ="  "
  IF %w < 1000 THEN ENDPROC =" "
ENDPROC =""

DEFPROC pad2(%w)
  IF %w < 10 THEN ENDPROC =" "
ENDPROC =""

DEFPROC onAnyKey()
  PRINT AT 10,21;"Press key"
  REPEAT : REPEAT UNTIL INKEY$ =""
  REPEAT : REPEAT UNTIL INKEY$ <> "" OR ( IN 31=16)
  REPEAT : REPEAT UNTIL INKEY$ =""
  PRINT AT 10,21;"         "
ENDPROC

DEFPROC pickRandom()
  ; default seed is 1 - to change this we need to BANK #BANKTILE DPOKE %1, %<16-bit> - but only during start game
  %r=% BANK 17 USR 0
  BANK 17 DPOKE %1,%r
ENDPROC =%r&3

DEFPROC loadAssets()
  BORDER 0: PAPER 0: CLS
  LOAD "./assets/font.bin" CODE 64000
  DPOKE 23606,63744: ; 64000-256 (256 = 8 * 32 control chars)
  LAYER 2,1
  PRINT CHR$ 2: ; trigger the font to be loaded on layer 2

  ; shadow L2 ends at 14, so we start at 15
  LOAD "assets/marbles.pal" BANK #BANKPAL
  LAYER PALETTE 0 BANK #BANKPAL,0
  SPRITE PALETTE 0 BANK #BANKPAL,0
  ; custom black and white
  BORDER 0: INK 255: PAPER 254: CLS

  LOAD "assets/marbles.spr" BANK #BANKSPR
  SPRITE BANK #BANKSPR
  SPRITE PRINT 1
  SPRITE BORDER 1

  TILE BANK #BANKSPR

  %i=0
  REPEAT
    READ %o
    BANK 17 POKE %i,%o
    %i=%i+1
  REPEAT UNTIL %o=201
ENDPROC

DEFPROC reset()
  SPRITE PRINT 0
  SPRITE CLEAR
  LAYER CLEAR
  PALETTE CLEAR
  LAYER 0
  CLS
ENDPROC

##########################################
# Joystick 1 callback procedures
# - MUST use these exactly procedure names
##########################################
DEFPROC U1()
  LOCAL %y
  %y=% SPRITE AT (#POINTER,1)
  IF %y > 1 THEN SPRITE #POINTER,,%y-1,,,
ENDPROC
DEFPROC L1()
  LOCAL %x
  %x=% SPRITE AT (#POINTER,0)
  IF %x > 1 THEN SPRITE #POINTER,%x-1,,,,
ENDPROC
DEFPROC D1()
  LOCAL %y
  %y=% SPRITE AT (#POINTER,1)
  IF %y < (256-1) THEN SPRITE #POINTER,,%y+1,,,
ENDPROC
DEFPROC R1()
  LOCAL %x
  %x=% SPRITE AT (#POINTER,0)
  IF %x < (320-1) THEN SPRITE #POINTER,%x+1,,,,
ENDPROC
DEFPROC F1()
  PROC selectBlock()
ENDPROC
DEFPROC F2()
  PROC selectBlock()
ENDPROC
DEFPROC F3()
  PROC selectBlock()
ENDPROC

; 16-bit xorshift pseudorandom number generator
; ld bc,1 : ld a,b: rra: ld a,c: rra: xor b: ld b,a: ld a,c: rra: ld a,b: rra: xor c: ld c,a: xor b: ld b,a: ret
DATA 1,1,0,120,31,121,31,168,71,121,31,120,31,169,79,168,71,201: ; length: 18

#autoline
9000 DEFPROC installMouse()
9010 ON ERROR GO TO 9030
9020 .uninstall /nextzxos/mouse.drv
9030 .install /nextzxos/mouse.drv
9040 ON ERROR
9050 ENDPROC

9060 DEFPROC installInput()
9070 ON ERROR GO TO 9090
9080 .uninstall assets/input.drv
9090 .install assets/input.drv
9100 ON ERROR
9110 ENDPROC
