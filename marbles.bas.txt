#autoline 10
#autostart 10
#program marbles

;-------------------------------------------------------------------------------
; VARIABLES
;
; %a[] - complete virtual grid of blocks and state
; %c[] - collected blocks when selection is made
; %p() - player state
;
; BUGS
; - [ ] If col 0 is empty it'll remain empty
;-------------------------------------------------------------------------------

RUN AT 3

ON ERROR GO TO 9200

#define BANKPAL=15
#define BANKSPR=16
#define BANKRND=17
#define BANKNEXTLEVEL=18
#define BANKPLOT=19
#define BANKGFX=20
#define BANKLIB=21
#define BANKDEBUG=0

; entry points in the marbles.bin library for methods and method constants
#define M_POPULATEGRID=437
#define M_RANDOMSEED=417
#define M_TAG=481
#define M_TAGINDEX=482

#define OFFSETRESTART=0
#define OFFSETNEWLEVEL=1309
#define OFFSETBUTTONS=2618

#define GRIDSTART=22

#define POINTER=127
#define POINTERSPR=63
#define COUNTER=126

#define DEVICE=1
#define SCORE=2
#define BUSY=3
#define BLOCKSLEFT=4
#define BEST=5
#define THEME=6
#define PLOTPTR=7
#define SEED=8
#define LEVEL=9

#define MOUSE=1
#define JOYSTICK=2
#define KEYBAORD=3

#define EMPTY=4

#define XMIN=0
#define XMAX=1
#define YMIN=2

%p(#DEVICE)=#KEYBAORD
%p(#SCORE)=0
%p(#THEME)=%1*5: ; or 2
%p(#SEED)=%$8f7a
%p(#BEST)=1036

PROC reset()
PROC loadAssets()
PROC selectInput()
PROC replayGame()

PROC mainLoop()

PAUSE 0

DEFPROC mainLoop()
  %i=0
  REPEAT
    PROC readInput()
    IF INKEY$ ="r" THEN PROC replayGame()
    IF INKEY$ ="n" THEN PROC newGame()
  REPEAT UNTIL 0
ENDPROC

DEFPROC nextLevel()
  %p(#LEVEL)=%p(#LEVEL)+1
  ; show Next Level box
  BANK #BANKNEXTLEVEL COPY TO 10

  ; FIXME test why the sprites aren't rendering over the layer even though it has priority on the palette
  SPRITE #COUNTER,97,113,58,1, BIN 0,1,1
  SPRITE #COUNTER-1,97,113,62,1, BIN 0,1,1: ; put a sprite under the countdown that's solid white, just in case we hide the counter before we clear the screen
  SPRITE CONTINUE #COUNTER, STOP , STOP ,58 TO 61, BIN 01100000,60,60: ; count down effect

  REPEAT
    SPRITE MOVE INT
  REPEAT UNTIL % SPRITE #COUNTER=0

  SPRITE #COUNTER-1,,,,0: ; remove the backing sprite

  CLS
  PROC printSeed()
  PROC loadBlocks()
ENDPROC

DEFPROC selectInput()
  PAPER 254: INK 255: BORDER 0
  LOAD "assets/welcome.nxi" LAYER

  ; settings loop
  PROC printSettings()
  LET start=0
  REPEAT
    k$= INKEY$
    IF k$="1" THEN %p(#DEVICE)=#MOUSE: PROC printSettings()
    IF k$="2" THEN %p(#DEVICE)=#JOYSTICK: PROC printSettings()
    IF k$="3" THEN %p(#DEVICE)=#KEYBAORD: PROC printSettings()

    IF k$="0" THEN start=1
    IF % IN 31=16 THEN %p(#DEVICE)=#JOYSTICK:start=1
  REPEAT UNTIL start=1

  IF %p(#DEVICE)=#MOUSE THEN PROC installMouse(): DRIVER 126,2,#POINTER,#POINTERSPR
  IF %p(#DEVICE) <> #MOUSE THEN PROC installInput(): SPRITE #POINTER,96,72,#POINTERSPR,1

  IF %(#DEVICE)=#JOYSTICK THEN DRIVER 125,2,3
  IF %(#DEVICE)=#KEYBAORD THEN DRIVER 125,2,5

  CLS
ENDPROC

DEFPROC printSettings()
  PRINT AT 5,8;"Select your input"
  DIM j$(3,18)
  j$(1)="1. Mouse"
  j$(2)="2. Joystick"
  j$(3)="3. Keyboard (QAOP)"

  FOR %i=1 TO 3
    j=%i
    PRINT AT %(i*2)+8,7; INVERSE %i=p(#DEVICE);j$(j)
  NEXT %i
  INVERSE 0
  PRINT AT %i+13,7;"0. START!"
ENDPROC

DEFPROC readInput()
  IF %p(#DEVICE)=#MOUSE THEN PROC readMouse(): ELSE PROC readJoystick(): ENDPROC
ENDPROC

DEFPROC readMouse()
  DRIVER 126,1 TO %b,%x,%y
  IF %b&@111 THEN PROC select()
ENDPROC

DEFPROC readJoystick()
  DRIVER 125,4,1
  REM 12345678901234567890123456789012345678901234567890
ENDPROC

DEFPROC select()
  %i=%( SPRITE OVER (#POINTER,0 TO 99)): ; which block are we over when we selected

  ; colliding 0 sprite returns 128 (can't remember why though!)
  IF %i=128 THEN %i=0

;   PROC pad2(%i) TO s$
;   PRINT AT 10,21;"SELECT  ";s$;%i

  IF %i > 99 THEN ENDPROC : ; out of scope

  IF %p(#BUSY) THEN ENDPROC

  PROC selectBlock()
ENDPROC

; %i = selected block
; Uses: %c, %i, %t
; Modifies: %p
DEFPROC selectBlock()

  %p(#BUSY)=1

  ; load %i into tagIndex
  BANK #BANKLIB POKE #M_TAGINDEX,%i
  ; call Tag()
  %t=% BANK #BANKLIB USR #M_TAG

  ; %t contains the address of the number of blocks tagged
  %c=% BANK #BANKLIB PEEK t

  IF %c < 2 THEN %p(#BUSY)=0: ENDPROC

  %p(#SCORE)=%p(#SCORE)+(c*(5+c))
  %p(#BLOCKSLEFT)=%p(#BLOCKSLEFT)-c
  BANK #BANKPLOT POKE %p(#PLOTPTR),%i: ; store the block cleared
  %p(#PLOTPTR)=%p(#PLOTPTR)+1

  ; clear the tagged blocks
  %x=9
  %y=9
  FOR %i=1 TO %c
    SPRITE % BANK #BANKLIB PEEK (t+i),,,#EMPTY,
    %j=%i MOD 10
    IF %j < x THEN %x=j
  NEXT %i

  INK 50
  PROC pad2(%c) TO s$
  PRINT AT 3,21;"CLEARED ";s$;%c
  PROC pad2(%p(#PLOTPTR)) TO s$
  PRINT AT 4,21;"MOVES   ";s$;%p(#PLOTPTR)
  PROC pad2(%p(#BLOCKSLEFT)) TO s$
  PRINT AT 5,21;"REMAIN  ";s$;%p(#BLOCKSLEFT)
  INK 255
  PROC pad4(%p(#SCORE)) TO s$
  PRINT AT 2,21;"SCORE ";s$;%p(#SCORE)

  ; now full render
  %c=100
  REPEAT
    %c=%c-1
    %i=% BANK #BANKLIB PEEK c
    IF %i < 255 THEN %i=%i+p(#THEME): ELSE %i=#EMPTY
    SPRITE %c,,,%i,

    ; slow down the render a little
;     IF %(n MOD 10)=0 THEN PROC readInput()
  REPEAT UNTIL %c=0

  %p(#BUSY)=0

ENDPROC

; param {int} %i
; returns {string} hex string
; uses: %j, h$, r$, p
DEFPROC toHex(%i)
  %j=4: ; symbols (2 bytes = 4 symbols)
  h$="0123456789abcdef"
  r$=""
  REPEAT : WHILE %j <> 0
    %j=%j-1
    p=%(i&$f)+1
    r$=h$(p)+r$
    %i=%i >> 4
  REPEAT UNTIL 0
ENDPROC =r$

DEFPROC startGame(%s)
  %p(#LEVEL)=1
  %p(#SCORE)=0
  BANK #BANKPLOT ERASE
  BANK #BANKPLOT DPOKE 0,%s: ; first 16bit word is the seed
  %p(#PLOTPTR)=2
  PROC setSeed(%s)
  PROC loadBlocks()

  IF #BANKDEBUG=0 THEN ENDPROC

  ; DEBUG - repeat a game sequence
  LOAD "./CRASH-2.BIN" BANK #BANKDEBUG



  %j=2
  REPEAT
    %i=% BANK #BANKDEBUG PEEK j
    WHILE %i <> 255
    PROC selectBlock()
    %j=%j+1
  REPEAT UNTIL 0
ENDPROC

DEFPROC replayGame()
  PROC startGame(%p(#SEED))
ENDPROC

DEFPROC newGame()
  PROC startGame(%1+ RND $fffe)
ENDPROC

DEFPROC loadBlocks()
  %p(#BLOCKSLEFT)=100

  INK 50
  PRINT AT 3,21;"CLEARED   0"
  PRINT AT 4,21;"MOVES     0"
  PRINT AT 5,21;"REMAIN  100"
  INK 255
  PRINT AT 2,21;"SCORE     0"
  PROC pad4(%p(#LEVEL)) TO s$
  PRINT AT 7,21;"LEVEL ";s$;%p(#LEVEL)

  BANK #BANKGFX LAYER #OFFSETBUTTONS TO 22,14,10,8

  ; call PopulateGrid
  %n=% BANK #BANKLIB USR #M_POPULATEGRID

  ; this uses a predefined order to render the blocks in a circle which makes
  ; for a nice effect
  %n=100
  RESTORE
  REPEAT
    %n=%n-1
    READ %j
    %r=% BANK #BANKLIB PEEK j
    PROC toXY(%j) TO %x,%y
    SPRITE %j,%(x*16)+32,%(y*16)+48,%r+p(#THEME),1
    %a[j]=%r
    PAUSE 1
  REPEAT UNTIL %n=0
ENDPROC

DEFPROC toXY(%n)
  %x=%n MOD 10
  %y=%n/10
ENDPROC =%x,%y

DEFPROC setSeed(%s)
  BANK #BANKLIB DPOKE %#M_RANDOMSEED,%s
  %p(#SEED)=%s
  PROC printSeed()
ENDPROC

DEFPROC printSeed()
  %s=%p(#SEED)
  PROC toHex(%s) TO s$
  INK 50
  PRINT AT 8,21;"SEED  #";s$
  PROC pad4(%p(#BEST)) TO s$
  PRINT AT 9,21;"BEST  ";s$;%p(#BEST)
ENDPROC

DEFPROC pad4(%w)
  IF %w < 10 THEN ENDPROC ="    "
  IF %w < 100 THEN ENDPROC ="   "
  IF %w < 1000 THEN ENDPROC ="  "
  IF %w < 10000 THEN ENDPROC =" "
ENDPROC =""

DEFPROC pad2(%w)
  IF %w < 10 THEN ENDPROC ="  "
  IF %w < 100 THEN ENDPROC =" "
ENDPROC =""

DEFPROC onAnyKey()
  PRINT AT 10,21;"Press key"
  REPEAT : REPEAT UNTIL INKEY$ =""
  REPEAT : REPEAT UNTIL INKEY$ <> "" OR ( IN 31=16)
  REPEAT : REPEAT UNTIL INKEY$ =""
  PRINT AT 10,21;"         "
ENDPROC

DEFPROC loadAssets()
  BORDER 0: PAPER 0: CLS
  LOAD "./assets/font.bin" CODE 64000
  DPOKE 23606,63744: ; 64000-256 (256 = 8 * 32 control chars)
  LAYER 2,1
  PRINT CHR$ 2: ; trigger the font to be loaded on layer 2

  LOAD "assets/over-next-level.bin" BANK #BANKNEXTLEVEL
  LOAD "assets/restart.nxi" BANK #BANKGFX,#OFFSETRESTART,1309
  LOAD "assets/new-level.nxi" BANK #BANKGFX,#OFFSETNEWLEVEL,1309
  LOAD "assets/buttons.nxi" BANK #BANKGFX,#OFFSETBUTTONS,5120
  LOAD "assets/marbles.bin" BANK #BANKLIB

  ; shadow L2 ends at 14, so we start at 15
  LOAD "assets/marbles.pal" BANK #BANKPAL
  LAYER PALETTE 0 BANK #BANKPAL,0
  SPRITE PALETTE 0 BANK #BANKPAL,0
  ; custom black and white
  BORDER 0: INK 255: PAPER 254: CLS

  LOAD "assets/marbles.spr" BANK #BANKSPR
  SPRITE BANK #BANKSPR
  SPRITE PRINT 1
  SPRITE BORDER 1

  POKE 23658,0: ; turn off CAPS LOCK (for menu items)
ENDPROC

DEFPROC reset()
  SPRITE PRINT 0
  SPRITE CLEAR
  LAYER CLEAR
  PALETTE CLEAR
  LAYER 0
  CLS
ENDPROC

##########################################
# Joystick 1 callback procedures
# - MUST use these exactly procedure names
##########################################
DEFPROC U1()
  LOCAL %y
  %y=% SPRITE AT (#POINTER,1)
  IF %y > 1 THEN SPRITE #POINTER,,%y-1,,,
ENDPROC
DEFPROC L1()
  LOCAL %x
  %x=% SPRITE AT (#POINTER,0)
  IF %x > 1 THEN SPRITE #POINTER,%x-1,,,,
ENDPROC
DEFPROC D1()
  LOCAL %y
  %y=% SPRITE AT (#POINTER,1)
  IF %y < (256-1) THEN SPRITE #POINTER,,%y+1,,,
ENDPROC
DEFPROC R1()
  LOCAL %x
  %x=% SPRITE AT (#POINTER,0)
  IF %x < (320-1) THEN SPRITE #POINTER,%x+1,,,,
ENDPROC
DEFPROC F1()
  PROC select()
ENDPROC
DEFPROC F2()
  PROC select()
ENDPROC
DEFPROC F3()
  PROC select()
ENDPROC

DEFPROC onAnyKey()
  REPEAT : REPEAT UNTIL INKEY$ =""
  REPEAT : REPEAT UNTIL INKEY$ <> "" OR ( IN 31=16)
  REPEAT : REPEAT UNTIL INKEY$ =""
ENDPROC

DATA 54,55,45,44,43,53,63,64,65,66,56,46,36,35,34,33,32,42,52,62,72,73,74,75,76,77,67,57,47,37,27,26,25,24,23,22,21,31,41,51,61,71,81,82,83,84,85,86,87,88,78,68,58,48,38,28,18,17,16,15,14,13,12,11,10,20,30,40,50,60,70,80,90,91,92,93,94,95,96,97,98,99,89,79,69,59,49,39,29,19,9,8,7,6,5,4,3,2,1,0

; the order to reveal the blocks on load encoded as 16 bit: x = i >> 4, y = i & $f
; DATA 1029,1285,1284,1028,772,773,774,1030,1286,1542,1541,1540,1539,1283,1027,771,515,516,517,518,519,775,1031,1287,1543,1799,1798,1797,1796,1795,1794,1538,1282,1026,770,514,258,259,260,261,262,263,264,520,776,1032,1288,1544,1800,2056,2055,2054,2053,2052,2051,2050,2049,1793,1537,1281,1025,769,513,257,1,2,3,4,5,6,7,8,9,265,521,777,1033,1289,1545,1801,2057,2313,2312,2311,2310,2309,2308,2307,2306,2305,2304,2048,1792,1536,1280,1024,768,512,256,0

#autoline
9000 DEFPROC installMouse()
9010 ON ERROR GO TO 9030
9020 .uninstall /nextzxos/mouse.drv
9030 .install /nextzxos/mouse.drv
9040 ON ERROR
9050 ENDPROC

9060 DEFPROC installInput()
9070 ON ERROR GO TO 9090
9080 .uninstall assets/input.drv
9090 .install assets/input.drv
9100 ON ERROR
9110 ENDPROC

# error handling needs to be outside a proc
9200 ERROR TO err,lin,st
9210 e$= STR$ err
9220 ON ERROR
9230 LAYER 2,1
9240 PALETTE CLEAR
9250 LAYER CLEAR
9260 SPRITE CLEAR
9270 BORDER 7: INK 0: PAPER 7
9280 CLS
9290 SPRITE PRINT 0: ; turn off sprites
9300 PRINT "Error:";e$;", line:";lin;", statement:";st
9310 REPEAT : REPEAT UNTIL INKEY$ =""
9320 REPEAT : REPEAT UNTIL INKEY$ <> "" OR ( IN 31=16)
9330 REPEAT : REPEAT UNTIL INKEY$ =""

